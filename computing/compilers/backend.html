<!DOCTYPE html><html lang="en">
  <head>
    <title>A tour of the LLVM backend | artagnon.com</title>
    <meta charset="utf-8">
    <meta name="description" content="Ramkumar Ramachandra&#39;s personal website">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="index,follow">
    <link rel="icon" type="image/x-icon" href="/dist/favicon.ico">
    <link rel="apple-touch-icon" sizes="58x58" href="/dist/touch-icon-iphone.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/dist/touch-icon-ipad.png">
    <link rel="apple-touch-icon" sizes="167x167" href="/dist/touch-icon-ipad-retina.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/dist/touch-icon-iphone-retina.png">
    <link rel="stylesheet" href="/dist/style.min.css">
    <link rel="stylesheet" href="/dist/rouge.min.css">
    <script defer="" src="https://cdn.jsdelivr.net/npm/cash-dom@8/dist/cash.min.js"></script>
    <script defer="" src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
    <script defer="" src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/relativeTime.js"></script>
    <script defer="" src="/dist/script.min.js"></script>
    <script defer="" data-domain="artagnon.com" src="https://analytics.artagnon.com/js/script.js"></script>
  <style id="MJX-CHTML-styles">
mjx-container[jax="CHTML"] {
  line-height: 0;
}

mjx-container [space="1"] {
  margin-left: .111em;
}

mjx-container [space="2"] {
  margin-left: .167em;
}

mjx-container [space="3"] {
  margin-left: .222em;
}

mjx-container [space="4"] {
  margin-left: .278em;
}

mjx-container [space="5"] {
  margin-left: .333em;
}

mjx-container [rspace="1"] {
  margin-right: .111em;
}

mjx-container [rspace="2"] {
  margin-right: .167em;
}

mjx-container [rspace="3"] {
  margin-right: .222em;
}

mjx-container [rspace="4"] {
  margin-right: .278em;
}

mjx-container [rspace="5"] {
  margin-right: .333em;
}

mjx-container [size="s"] {
  font-size: 70.7%;
}

mjx-container [size="ss"] {
  font-size: 50%;
}

mjx-container [size="Tn"] {
  font-size: 60%;
}

mjx-container [size="sm"] {
  font-size: 85%;
}

mjx-container [size="lg"] {
  font-size: 120%;
}

mjx-container [size="Lg"] {
  font-size: 144%;
}

mjx-container [size="LG"] {
  font-size: 173%;
}

mjx-container [size="hg"] {
  font-size: 207%;
}

mjx-container [size="HG"] {
  font-size: 249%;
}

mjx-container [width="full"] {
  width: 100%;
}

mjx-box {
  display: inline-block;
}

mjx-block {
  display: block;
}

mjx-itable {
  display: inline-table;
}

mjx-row {
  display: table-row;
}

mjx-row > * {
  display: table-cell;
}

mjx-mtext {
  display: inline-block;
}

mjx-mstyle {
  display: inline-block;
}

mjx-merror {
  display: inline-block;
  color: red;
  background-color: yellow;
}

mjx-mphantom {
  visibility: hidden;
}

_::-webkit-full-page-media, _:future, :root mjx-container {
  will-change: opacity;
}

mjx-math {
  display: inline-block;
  text-align: left;
  line-height: 0;
  text-indent: 0;
  font-style: normal;
  font-weight: normal;
  font-size: 100%;
  font-size-adjust: none;
  letter-spacing: normal;
  border-collapse: collapse;
  word-wrap: normal;
  word-spacing: normal;
  white-space: nowrap;
  direction: ltr;
  padding: 1px 0;
}

mjx-container[jax="CHTML"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="CHTML"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="CHTML"][display="true"] mjx-math {
  padding: 0;
}

mjx-container[jax="CHTML"][justify="left"] {
  text-align: left;
}

mjx-container[jax="CHTML"][justify="right"] {
  text-align: right;
}

mjx-mi {
  display: inline-block;
  text-align: left;
}

mjx-c {
  display: inline-block;
}

mjx-utext {
  display: inline-block;
  padding: .75em 0 .2em 0;
}

mjx-mn {
  display: inline-block;
  text-align: left;
}

mjx-mo {
  display: inline-block;
  text-align: left;
}

mjx-stretchy-h {
  display: inline-table;
  width: 100%;
}

mjx-stretchy-h > * {
  display: table-cell;
  width: 0;
}

mjx-stretchy-h > * > mjx-c {
  display: inline-block;
  transform: scalex(1.0000001);
}

mjx-stretchy-h > * > mjx-c::before {
  display: inline-block;
  width: initial;
}

mjx-stretchy-h > mjx-ext {
  /* IE */ overflow: hidden;
  /* others */ overflow: clip visible;
  width: 100%;
}

mjx-stretchy-h > mjx-ext > mjx-c::before {
  transform: scalex(500);
}

mjx-stretchy-h > mjx-ext > mjx-c {
  width: 0;
}

mjx-stretchy-h > mjx-beg > mjx-c {
  margin-right: -.1em;
}

mjx-stretchy-h > mjx-end > mjx-c {
  margin-left: -.1em;
}

mjx-stretchy-v {
  display: inline-block;
}

mjx-stretchy-v > * {
  display: block;
}

mjx-stretchy-v > mjx-beg {
  height: 0;
}

mjx-stretchy-v > mjx-end > mjx-c {
  display: block;
}

mjx-stretchy-v > * > mjx-c {
  transform: scaley(1.0000001);
  transform-origin: left center;
  overflow: hidden;
}

mjx-stretchy-v > mjx-ext {
  display: block;
  height: 100%;
  box-sizing: border-box;
  border: 0px solid transparent;
  /* IE */ overflow: hidden;
  /* others */ overflow: visible clip;
}

mjx-stretchy-v > mjx-ext > mjx-c::before {
  width: initial;
  box-sizing: border-box;
}

mjx-stretchy-v > mjx-ext > mjx-c {
  transform: scaleY(500) translateY(.075em);
  overflow: visible;
}

mjx-mark {
  display: inline-block;
  height: 0px;
}

mjx-c::before {
  display: block;
  width: 0;
}

.MJX-TEX {
  font-family: MJXZERO, MJXTEX;
}

.TEX-B {
  font-family: MJXZERO, MJXTEX-B;
}

.TEX-I {
  font-family: MJXZERO, MJXTEX-I;
}

.TEX-MI {
  font-family: MJXZERO, MJXTEX-MI;
}

.TEX-BI {
  font-family: MJXZERO, MJXTEX-BI;
}

.TEX-S1 {
  font-family: MJXZERO, MJXTEX-S1;
}

.TEX-S2 {
  font-family: MJXZERO, MJXTEX-S2;
}

.TEX-S3 {
  font-family: MJXZERO, MJXTEX-S3;
}

.TEX-S4 {
  font-family: MJXZERO, MJXTEX-S4;
}

.TEX-A {
  font-family: MJXZERO, MJXTEX-A;
}

.TEX-C {
  font-family: MJXZERO, MJXTEX-C;
}

.TEX-CB {
  font-family: MJXZERO, MJXTEX-CB;
}

.TEX-FR {
  font-family: MJXZERO, MJXTEX-FR;
}

.TEX-FRB {
  font-family: MJXZERO, MJXTEX-FRB;
}

.TEX-SS {
  font-family: MJXZERO, MJXTEX-SS;
}

.TEX-SSB {
  font-family: MJXZERO, MJXTEX-SSB;
}

.TEX-SSI {
  font-family: MJXZERO, MJXTEX-SSI;
}

.TEX-SC {
  font-family: MJXZERO, MJXTEX-SC;
}

.TEX-T {
  font-family: MJXZERO, MJXTEX-T;
}

.TEX-V {
  font-family: MJXZERO, MJXTEX-V;
}

.TEX-VB {
  font-family: MJXZERO, MJXTEX-VB;
}

mjx-stretchy-v mjx-c, mjx-stretchy-h mjx-c {
  font-family: MJXZERO, MJXTEX-S1, MJXTEX-S4, MJXTEX, MJXTEX-A ! important;
}

@font-face /* 0 */ {
  font-family: MJXZERO;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Zero.woff") format("woff");
}

@font-face /* 1 */ {
  font-family: MJXTEX;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Regular.woff") format("woff");
}

@font-face /* 2 */ {
  font-family: MJXTEX-B;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Bold.woff") format("woff");
}

@font-face /* 3 */ {
  font-family: MJXTEX-I;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-Italic.woff") format("woff");
}

@font-face /* 4 */ {
  font-family: MJXTEX-MI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Italic.woff") format("woff");
}

@font-face /* 5 */ {
  font-family: MJXTEX-BI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-BoldItalic.woff") format("woff");
}

@font-face /* 6 */ {
  font-family: MJXTEX-S1;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size1-Regular.woff") format("woff");
}

@font-face /* 7 */ {
  font-family: MJXTEX-S2;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size2-Regular.woff") format("woff");
}

@font-face /* 8 */ {
  font-family: MJXTEX-S3;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size3-Regular.woff") format("woff");
}

@font-face /* 9 */ {
  font-family: MJXTEX-S4;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size4-Regular.woff") format("woff");
}

@font-face /* 10 */ {
  font-family: MJXTEX-A;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_AMS-Regular.woff") format("woff");
}

@font-face /* 11 */ {
  font-family: MJXTEX-C;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Regular.woff") format("woff");
}

@font-face /* 12 */ {
  font-family: MJXTEX-CB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Bold.woff") format("woff");
}

@font-face /* 13 */ {
  font-family: MJXTEX-FR;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Regular.woff") format("woff");
}

@font-face /* 14 */ {
  font-family: MJXTEX-FRB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Bold.woff") format("woff");
}

@font-face /* 15 */ {
  font-family: MJXTEX-SS;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Regular.woff") format("woff");
}

@font-face /* 16 */ {
  font-family: MJXTEX-SSB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Bold.woff") format("woff");
}

@font-face /* 17 */ {
  font-family: MJXTEX-SSI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Italic.woff") format("woff");
}

@font-face /* 18 */ {
  font-family: MJXTEX-SC;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Script-Regular.woff") format("woff");
}

@font-face /* 19 */ {
  font-family: MJXTEX-T;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Typewriter-Regular.woff") format("woff");
}

@font-face /* 20 */ {
  font-family: MJXTEX-V;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Regular.woff") format("woff");
}

@font-face /* 21 */ {
  font-family: MJXTEX-VB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Bold.woff") format("woff");
}

mjx-c.mjx-c1D465.TEX-I::before {
  padding: 0.442em 0.572em 0.011em 0;
  content: "x";
}

mjx-c.mjx-c31::before {
  padding: 0.666em 0.5em 0 0;
  content: "1";
}

mjx-c.mjx-c36::before {
  padding: 0.666em 0.5em 0.022em 0;
  content: "6";
}

mjx-c.mjx-c3D::before {
  padding: 0.583em 0.778em 0.082em 0;
  content: "=";
}

mjx-c.mjx-c1D434.TEX-I::before {
  padding: 0.716em 0.75em 0 0;
  content: "A";
}

mjx-c.mjx-c1D437.TEX-I::before {
  padding: 0.683em 0.828em 0 0;
  content: "D";
}

mjx-c.mjx-c1D43C.TEX-I::before {
  padding: 0.683em 0.504em 0 0;
  content: "I";
}
</style></head>
  <body class="wrapper">
    <nav><a href="/"><img id="logo" src="/dist/artagnon.com.svg" alt="home" width="317" height="390"></a><img id="more" src="/dist/icon.more.svg" alt="menu" width="16" height="74">
      <ul>
        <li>
          <span class="navidx">01</span><a href="/art">art</a>
        </li>
        <li>
          <span class="navidx">02</span><a href="/computing">computing</a>
        </li>
        <li>
          <span class="navidx">03</span><a href="/logic">logic</a>
        </li>
        <li>
          <span class="navidx">04</span><a href="/math">math</a>
        </li>
      </ul>
    </nav>
    <main>
      <header>
        <h1>
          A tour of the LLVM backend
        </h1>
        <div id="metadata">
          <span id="timestamp"><time class="end" datetime="2024-08-04">Sun, 4 Aug 2024 21:00:00 +0100</time></span>
        </div>
      </header>
      <article>
        <p>
          In this article, we illustrate the operation of a the main components of a compiler's backend, with emphasis on instruction selection, instruction scheduling, and register allocation, using LLVM as the reference compiler. We use the RISC-V target for the purposes of concrete illustrations. Let's take a simple C program as our guiding example, and have a look at each step of the lowering after running the entire middle-end optimization pipeline, until we get the final assembly.
        </p>
        <pre><code class="highlight"><span class="cp">#define N 64
</span>
<span class="kt">void</span> <span class="nf">matmul</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">y</span><span class="p">,</span>
            <span class="kt">float</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
        <span class="n">res</span><span class="p">[</span><span class="n">N</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">N</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">N</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>
<span class="p">}</span></code></pre>
        <p>
          First, we run the full middle-end optimization pipeline to obtain the optimized LLVM IR that's handed off to the backend. Running <mark>clang --target=riscv64 -march=rv64gc -O3 -emit-llvm -S</mark> emits:
        </p>
        <pre><code class="highlight"><span class="k">define</span> <span class="kt">void</span> <span class="vg">@matmul</span><span class="p">(</span><span class="err">ptr</span> <span class="k">noalias</span> <span class="nv">%x</span><span class="p">,</span> <span class="err">ptr</span> <span class="k">noalias</span> <span class="nv">%y</span><span class="p">,</span> <span class="err">ptr</span> <span class="k">noalias</span> <span class="nv">%res</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%ph</span>

<span class="nl">ph:</span>
  <span class="nv">%iv.outer</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">i64</span> <span class="p">[</span> <span class="m">0</span><span class="p">,</span> <span class="nv">%entry</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%iv.outer.next</span><span class="p">,</span> <span class="nv">%common.exit</span> <span class="p">]</span>
  <span class="nv">%shl</span> <span class="p">=</span> <span class="k">shl</span> <span class="k">nuw</span> <span class="k">nsw</span> <span class="kt">i64</span> <span class="nv">%iv.outer</span><span class="p">,</span> <span class="m">6</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%common.ph</span>

<span class="nl">exit:</span>
  <span class="k">ret</span> <span class="kt">void</span>

<span class="nl">common.ph:</span>
  <span class="nv">%iv.middle</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">i64</span> <span class="p">[</span> <span class="m">0</span><span class="p">,</span> <span class="nv">%ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%iv.middle.next</span><span class="p">,</span> <span class="nv">%inner.loop.exit</span> <span class="p">]</span>
  <span class="nv">%or</span> <span class="p">=</span> <span class="k">or</span> <span class="err">disjoint</span> <span class="kt">i64</span> <span class="nv">%iv.middle</span><span class="p">,</span> <span class="nv">%shl</span>
  <span class="nv">%gep.res</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="kt">float</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%res</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%or</span>
  <span class="nv">%load</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">float</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%gep.res</span>
  <span class="nv">%gep.y</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="kt">float</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%y</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%iv.middle</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%inner.loop</span>

<span class="nl">common.exit:</span>
  <span class="nv">%iv.outer.next</span> <span class="p">=</span> <span class="k">add</span> <span class="k">nuw</span> <span class="k">nsw</span> <span class="kt">i64</span> <span class="nv">%iv.outer</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%exit.cond.outer</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i64</span> <span class="nv">%iv.outer.next</span><span class="p">,</span> <span class="m">64</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%exit.cond.outer</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%ph</span>

<span class="nl">inner.loop.exit:</span>
  <span class="k">store</span> <span class="kt">float</span> <span class="nv">%conv.next</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%gep.res</span>
  <span class="err">iv</span><span class="p">.</span><span class="err">middle</span><span class="p">.</span><span class="err">next</span> <span class="p">=</span> <span class="k">add</span> <span class="k">nuw</span> <span class="k">nsw</span> <span class="kt">i64</span> <span class="nv">%iv.middle</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%exit.cond.middle</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i64</span> <span class="nv">%iv.middle.next</span><span class="p">,</span> <span class="m">64</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%exit.cond.middle</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%common.exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%common.ph</span>

<span class="nl">inner.loop:</span>
  <span class="nv">%iv</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">i64</span> <span class="p">[</span> <span class="m">0</span><span class="p">,</span> <span class="nv">%common.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%iv.next</span><span class="p">,</span> <span class="nv">%inner.loop</span> <span class="p">]</span>
  <span class="nv">%conv</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">float</span> <span class="p">[</span> <span class="nv">%load</span><span class="p">,</span> <span class="nv">%common.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%conv.next</span><span class="p">,</span> <span class="nv">%inner.loop</span> <span class="p">]</span>
  <span class="nv">%or</span> <span class="p">=</span> <span class="k">or</span> <span class="err">disjoint</span> <span class="kt">i64</span> <span class="nv">%iv</span><span class="p">,</span> <span class="nv">%shl</span>
  <span class="nv">%gep.x</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="kt">float</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%or</span>
  <span class="nv">%load.x</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">float</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%gep.x</span>
  <span class="nv">%shl.iv</span> <span class="p">=</span> <span class="k">shl</span> <span class="k">nuw</span> <span class="k">nsw</span> <span class="kt">i64</span> <span class="nv">%iv</span><span class="p">,</span> <span class="m">6</span>
  <span class="nv">%gep.y.2</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="kt">float</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%gep.y</span><span class="p">,</span> <span class="kt">i64</span> <span class="nv">%shl.iv</span>
  <span class="nv">%load.y</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">float</span><span class="p">,</span> <span class="err">ptr</span> <span class="nv">%gep.y.2</span>
  <span class="nv">%conv.next</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="kt">float</span> <span class="vg">@llvm.fmuladd.f32</span><span class="p">(</span>
               <span class="kt">float</span> <span class="nv">%load.x</span><span class="p">,</span> <span class="kt">float</span> <span class="nv">%load.y</span><span class="p">,</span> <span class="kt">float</span> <span class="nv">%conv</span><span class="p">)</span>
  <span class="nv">%iv.next</span> <span class="p">=</span> <span class="k">add</span> <span class="k">nuw</span> <span class="k">nsw</span> <span class="kt">i64</span> <span class="nv">%iv</span><span class="p">,</span> <span class="m">1</span>
  <span class="nv">%exit.cond</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="kt">i64</span> <span class="nv">%iv.next</span><span class="p">,</span> <span class="m">64</span>
  <span class="k">br</span> <span class="kt">i1</span> <span class="nv">%exit.cond</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%inner.loop.exit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%inner.loop</span>
<span class="p">}</span></code></pre>
        <p>
          The astute reader will note that we have strategically omitted the vector extension of RISC-V (we use <mark>-march=rv64gc</mark> instead of <mark>-march=rv64gcv</mark>) to avoid unnecessarily complicating the exposition due to the vectorization passes in LLVM. Auto-vectorization has already been discussed in depth <a href="/computing/compilers/intro-vec">previously</a>.
        </p>
        <p>
          The first thing to notice is that the body of the function is cleanly separated into three basic blocks: entry, ph, common.ph, inner.loop, inner.loop.exit, common.exit, and exit. Next, notice that the IR is in single-static-assignment (SSA) form, which means is that variables like <mark>%iv</mark> are only ever defined once. Since this is a loop that requires incrementing the induction variable, a fresh <mark>%iv.next</mark> variable is created, and <mark>%iv</mark> is a <mark>phi</mark> node that selects between the values <mark>0</mark> when jumping into the <mark>loop</mark> block from <mark>entry</mark>, and <mark>%iv.next</mark> when jumping to the <mark>loop</mark> block from the back-edge of the loop. All the instructions (load, getelementptr, store, or, shl etc.) are target-independent instructions that are used throughout the LLVM middle-end. The target-specific instructions will only be seen after instruction selection.
        </p>
        <p>
          The first step in the lowering process is instruction selection. We can look at the output after this step by running <mark>llc --print-after-isel</mark>:
        </p>
        <pre><code class="highlight">Function Live Ins: $x10 in %18, $x11 in %19, $x12 in %20

bb.0 (%ir-block.3):
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $x10, $x11, $x12
  %20:gpr = COPY $x12
  %19:gpr = COPY $x11
  %18:gpr = COPY $x10
  %22:gpr = COPY $x0
  %21:gpr = COPY %22:gpr

bb.1 (%ir-block.4):
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  %0:gpr = PHI %18:gpr, %bb.0, %9:gpr, %bb.4
  %1:gpr = PHI %21:gpr, %bb.0, %8:gpr, %bb.4
  %2:gpr = nuw nsw SLLI %1:gpr, 6
  %24:gpr = COPY $x0
  %23:gpr = COPY %24:gpr
  PseudoBR %bb.3

bb.2 (%ir-block.7):
  PseudoRET

bb.3 (%ir-block.8):
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  %3:gpr = PHI %19:gpr, %bb.1, %11:gpr, %bb.5
  %4:gpr = PHI %23:gpr, %bb.1, %10:gpr, %bb.5
  %25:gpr = nuw nsw SLLI %4:gpr, 2
  %26:gpr = ADD killed %25:gpr, %19:gpr
  %27:gpr = LUI 4
  %5:gpr = ADD killed %26:gpr, killed %27:gpr
  %28:gpr = OR %4:gpr, %2:gpr
  %29:gpr = SLLI killed %28:gpr, 2
  %6:gpr = ADD %20:gpr, killed %29:gpr
  %7:fpr32 = FLW %6:gpr, 0
  PseudoBR %bb.6

bb.4 (%ir-block.15):
  successors: %bb.2(0x04000000), %bb.1(0x7c000000);
              %bb.2(3.12%), %bb.1(96.88%)
  %8:gpr = nuw nsw ADDI %1:gpr, 1
  %9:gpr = ADDI %0:gpr, 256
  %33:gpr = ADDI $x0, 64
  BEQ %8:gpr, killed %33:gpr, %bb.2
  PseudoBR %bb.1

bb.5 (%ir-block.18):
  successors: %bb.4(0x04000000), %bb.3(0x7c000000);
              %bb.4(3.12%), %bb.3(96.88%)
  FSW %15:fpr32, %6:gpr, 0
  %10:gpr = nuw nsw ADDI %4:gpr, 1
  %11:gpr = ADDI %3:gpr, 4
  %32:gpr = ADDI $x0, 64
  BEQ %10:gpr, killed %32:gpr, %bb.4
  PseudoBR %bb.3

bb.6 (%ir-block.21):
  successors: %bb.5(0x04000000), %bb.6(0x7c000000);
              %bb.5(3.12%), %bb.6(96.88%)
  %12:gpr = PHI %0:gpr, %bb.3, %17:gpr, %bb.6
  %13:gpr = PHI %3:gpr, %bb.3, %16:gpr, %bb.6
  %14:fpr32 = PHI %7:fpr32, %bb.3, %15:fpr32, %bb.6
  %30:fpr32 = FLW %12:gpr, 0
  %31:fpr32 = FLW %13:gpr, 0
  %15:fpr32 = nofpexcept FMADD_S killed %30:fpr32,
              killed %31:fpr32, %14:fpr32, 7, implicit $frm
  %16:gpr = ADDI %13:gpr, 256
  %17:gpr = ADDI %12:gpr, 4
  BEQ %16:gpr, %5:gpr, %bb.5
  PseudoBR %bb.6</code></pre>
        <p>
          What we see is a relatively straight-forward translation of the middle-end LLVM IR to machine IR (MIR), preserving the basic block structure and SSA-form. The purpose of the instruction selection framework is to select a combination of instructions available on the target that optimally represents the middle-end semantics. Its two primary functions are to replace middle-end SSA variables by virtual registers, and replace middle-end instructions by target-specific instructions.
        </p>
        <p>
          Each virtual register has a suffix of either gpr, or general-purpose register, and fpr, or floating-point register. There are also real registers in this MIR: <mark>$x0</mark>, <mark>$x10</mark>, <mark>$x11</mark>, <mark>$x12</mark>, <mark>$frm</mark>. Per RISC-V calling convention, the first three arguments to a function are in general-purpose registers <mark>$x10</mark>, <mark>$x11</mark>, and <mark>$x12</mark> (pretty-printed as <mark>a0</mark>, <mark>a1</mark>, and <mark>a2</mark>). <mark>$x0</mark> is a special register on RISC-V that always holds the value <mark>0</mark>. <mark>$frm</mark> is the floating-point rounding-mode register. None of these can be virtual registers. A minor point to notice is the annotations on the virtual registers, <mark>killed</mark> and <mark>implicit</mark>. The operands of the <mark>FMADD_S</mark>, <mark>%30:fpr32</mark> and <mark>%21:fpr32</mark>, are marked as <mark>killed</mark>, meaning that this is the final definition/use of those registers (these annotations are preliminary: the final annotations will be determined at a later stage). The register <mark>$frm</mark> is marked as <mark>implicit</mark>, meaning that it implicitly uses this register, and this argument will be absent in the final assembly.
        </p>
        <p>
          Middle-end instructions like <mark>@llvm.fmadd</mark> have been replaced by target-specific instructions like <mark>FMADD_S</mark> (pretty-printed as <mark>fmadd.s</mark>), and several pseudo-instructions like <mark>PseudoBR</mark> and <mark>PHI</mark> which will not be present in the final assembly have been inserted in the process.
        </p>
        <p>
          There is some minor additional information in this MIR: the live-ins, or registers that are live at the point of entry; and the branch frequency information: <mark>bb.6</mark> is going to be the successor basic-block of <mark>bb.6</mark> 97% of the time.
        </p>
        <p>
          Although the instruction selection infrastructure, or SelectionDAG †, is target-independent, we can see that our MIR is clearly specialized for RISC-V. All the information about the registers available on RISC-V are defined in <a href="https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/RISCV/RISCVRegisterInfo.td">RISCVRegisterInfo.td</a>. The instructions on RISC-V themselves come out of the specification <a href="https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/RISCV/RISCVInstrInfo.td">RISCVInstrInfo.td</a>, and the target-specific code that specifies how middle-end instructions should be lowered to instructions in this specification via SelectionDAG is <a href="https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/RISCV/RISCVISelLowering.cpp">RISCVISelLowering.cpp</a>.
        </p>
        <p>
          In order to understand the various steps after instruction selection, let us <a href="https://godbolt.org/z/TxzjEMr5M">inspect the diffs</a> produced by running <mark>llc -print-changed=diff</mark>.
        </p>
        <p>
          The first significant pass to run after the instruction selection is <mark>early-machinelicm</mark>, which is just a backend version of the middle-end loop invariant code motion transform. Next, we have <mark>livevars</mark>, which analyzes live variables, and marks variables as <mark>killed</mark> aggressively (many of these annotations will be undone by a later analysis).
        </p>
        <p>
          <mark>phi-node-elimination</mark> runs next, which removes PHI nodes, leaving the MIR in SSA form by inserting pseudo COPY instructions:
        </p>
        <pre><code class="highlight">  Function Live Ins: $x10 in %18, $x11 in %19, $x12 in %20

  bb.0 (%ir-block.3):
   successors: %bb.1(0x80000000); %bb.1(100.00%)
   liveins: $x10, $x11, $x12
   %20:gpr = COPY killed $x12
   %19:gpr = COPY killed $x11
   %18:gpr = COPY killed $x10
   %22:gpr = COPY $x0
   %21:gpr = COPY killed %22:gpr
   %27:gpr = LUI 4
   %32:gpr = ADDI $x0, 64
<span class="gi">+  %36:gpr = COPY killed %18:gpr
+  %37:gpr = COPY killed %21:gpr
</span>
 bb.1 (%ir-block.4):
   successors: %bb.3(0x80000000); %bb.3(100.00%)
<span class="gd">-  %0:gpr = PHI %18:gpr, %bb.0, %9:gpr, %bb.4
-  %1:gpr = PHI %21:gpr, %bb.0, %8:gpr, %bb.4
</span><span class="gi">+  %1:gpr = COPY killed %37:gpr
+  %0:gpr = COPY killed %36:gpr
</span>   %2:gpr = nuw nsw SLLI %1:gpr, 6
   %24:gpr = COPY $x0
   %23:gpr = COPY killed %24:gpr
<span class="gi">+  %38:gpr = COPY %19:gpr
+  %39:gpr = COPY killed %23:gpr
</span>   PseudoBR %bb.3

 bb.2 (%ir-block.7):
   PseudoRET

 bb.3 (%ir-block.8):
   successors: %bb.6(0x80000000); %bb.6(100.00%)
<span class="gd">-  %3:gpr = PHI %19:gpr, %bb.1, %11:gpr, %bb.5
-  %4:gpr = PHI %23:gpr, %bb.1, %10:gpr, %bb.5
</span><span class="gi">+  %4:gpr = COPY killed %39:gpr
+  %3:gpr = COPY killed %38:gpr
</span>   %25:gpr = nuw nsw SLLI %4:gpr, 2
   %26:gpr = ADD killed %25:gpr, %19:gpr
   %5:gpr = ADD killed %26:gpr, %27:gpr
   %28:gpr = OR %4:gpr, %2:gpr
   %29:gpr = SLLI killed %28:gpr, 2
   %6:gpr = ADD %20:gpr, killed %29:gpr
   %7:fpr32 = FLW %6:gpr, 0
<span class="gi">+  %40:gpr = COPY %0:gpr
+  %41:gpr = COPY %3:gpr
+  %42:fpr32 = COPY killed %7:fpr32
</span>   PseudoBR %bb.6

 bb.4 (%ir-block.15):
   successors: %bb.2(0x04000000), %bb.1(0x7c000000);
               %bb.2(3.12%), %bb.1(96.88%)
   %8:gpr = nuw nsw ADDI killed %1:gpr, 1
   %9:gpr = ADDI killed %0:gpr, 256
<span class="gd">-  BEQ %8:gpr, %32:gpr, %bb.2
</span><span class="gi">+  %36:gpr = COPY killed %9:gpr
+  %37:gpr = COPY %8:gpr
+  BEQ killed %8:gpr, %32:gpr, %bb.2
</span>   PseudoBR %bb.1

 bb.5 (%ir-block.18):
   successors: %bb.4(0x04000000), %bb.3(0x7c000000);
               %bb.4(3.12%), %bb.3(96.88%)
   FSW killed %15:fpr32, killed %6:gpr, 0
   %10:gpr = nuw nsw ADDI killed %4:gpr, 1
   %11:gpr = ADDI killed %3:gpr, 4
<span class="gd">-  BEQ %10:gpr, %32:gpr, %bb.4
</span><span class="gi">+  %38:gpr = COPY killed %11:gpr
+  %39:gpr = COPY %10:gpr
+  BEQ killed %10:gpr, %32:gpr, %bb.4
</span>   PseudoBR %bb.3

 bb.6 (%ir-block.21):
   successors: %bb.5(0x04000000), %bb.6(0x7c000000);
               %bb.5(3.12%), %bb.6(96.88%)
<span class="gd">-  %12:gpr = PHI %0:gpr, %bb.3, %17:gpr, %bb.6
-  %13:gpr = PHI %3:gpr, %bb.3, %16:gpr, %bb.6
-  %14:fpr32 = PHI %7:fpr32, %bb.3, %15:fpr32, %bb.6
</span><span class="gi">+  %14:fpr32 = COPY killed %42:fpr32
+  %13:gpr = COPY killed %41:gpr
+  %12:gpr = COPY killed %40:gpr
</span>   %30:fpr32 = FLW %12:gpr, 0
   %31:fpr32 = FLW %13:gpr, 0
   %15:fpr32 = nofpexcept FMADD_S killed %30:fpr32,
               killed %31:fpr32, killed %14:fpr32,
               7, implicit $frm
   %16:gpr = ADDI killed %13:gpr, 256
   %17:gpr = ADDI killed %12:gpr, 4
<span class="gd">-  BEQ %16:gpr, %5:gpr, %bb.5
</span><span class="gi">+  %40:gpr = COPY killed %17:gpr
+  %41:gpr = COPY %16:gpr
+  %42:fpr32 = COPY %15:fpr32
+  BEQ killed %16:gpr, %5:gpr, %bb.5
</span>   PseudoBR %bb.6</code></pre>
        <p>
          The next pass is <mark>liveintervals</mark>, which undoes many of the <mark>killed</mark> annotations inserted by <mark>livevars</mark>, by performing a more sophisticated analysis to determine the actual virtual registers killed in the loop-nest.
        </p>
        <p>
          The final preparatory step before instruction scheduling and register allocation is <mark>register-coalescer</mark>, which eliminates many of the COPY instructions, taking the MIR out of SSA form:
        </p>
        <pre><code class="highlight"> Function Live Ins: $x10 in %18, $x11 in %19, $x12 in %20

 bb.0 (%ir-block.3):
   successors: %bb.1(0x80000000); %bb.1(100.00%)
   liveins: $x10, $x11, $x12
   %20:gpr = COPY $x12
   %19:gpr = COPY $x11
<span class="gd">-  %18:gpr = COPY $x10
-  %22:gpr = COPY $x0
-  %21:gpr = COPY %22:gpr
</span><span class="gi">+  %0:gpr = COPY $x10
</span>   %27:gpr = LUI 4
   %32:gpr = ADDI $x0, 64
<span class="gd">-  %36:gpr = COPY %18:gpr
-  %37:gpr = COPY %21:gpr
</span><span class="gi">+  %1:gpr = COPY $x0
</span>
 bb.1 (%ir-block.4):
   successors: %bb.3(0x80000000); %bb.3(100.00%)
<span class="gd">-  %1:gpr = COPY %37:gpr
-  %0:gpr = COPY %36:gpr
</span>   %2:gpr = nuw nsw SLLI %1:gpr, 6
<span class="gd">-  %24:gpr = COPY $x0
-  %23:gpr = COPY %24:gpr
-  %38:gpr = COPY %19:gpr
-  %39:gpr = COPY %23:gpr
</span><span class="gi">+  %3:gpr = COPY %19:gpr
+  %4:gpr = COPY $x0
</span>   PseudoBR %bb.3

 bb.2 (%ir-block.7):
   PseudoRET

 bb.3 (%ir-block.8):
   successors: %bb.6(0x80000000); %bb.6(100.00%)
<span class="gd">-  %4:gpr = COPY %39:gpr
-  %3:gpr = COPY %38:gpr
</span>   %25:gpr = nuw nsw SLLI %4:gpr, 2
   %26:gpr = ADD %25:gpr, %19:gpr
   %5:gpr = ADD %26:gpr, %27:gpr
   %28:gpr = OR %4:gpr, %2:gpr
   %29:gpr = SLLI %28:gpr, 2
   %6:gpr = ADD %20:gpr, %29:gpr
<span class="gd">-  %7:fpr32 = FLW %6:gpr, 0
</span><span class="gi">+  %42:fpr32 = FLW %6:gpr, 0
</span>   %40:gpr = COPY %0:gpr
   %41:gpr = COPY %3:gpr
<span class="gd">-  %42:fpr32 = COPY %7:fpr32
</span>   PseudoBR %bb.6

 bb.4 (%ir-block.15):
   successors: %bb.2(0x04000000), %bb.1(0x7c000000);
               %bb.2(3.12%), %bb.1(96.88%)
<span class="gd">-  %8:gpr = nuw nsw ADDI %1:gpr, 1
-  %9:gpr = ADDI %0:gpr, 256
-  %36:gpr = COPY %9:gpr
-  %37:gpr = COPY %8:gpr
-  BEQ %8:gpr, %32:gpr, %bb.2
</span><span class="gi">+  %1:gpr = nuw nsw ADDI %1:gpr, 1
+  %0:gpr = ADDI %0:gpr, 256
+  BEQ %1:gpr, %32:gpr, %bb.2
</span>   PseudoBR %bb.1

 bb.5 (%ir-block.18):
   successors: %bb.4(0x04000000), %bb.3(0x7c000000);
               %bb.4(3.12%), %bb.3(96.88%)
<span class="gd">-  FSW %15:fpr32, %6:gpr, 0
-  %10:gpr = nuw nsw ADDI %4:gpr, 1
-  %11:gpr = ADDI %3:gpr, 4
-  %38:gpr = COPY %11:gpr
-  %39:gpr = COPY %10:gpr
-  BEQ %10:gpr, %32:gpr, %bb.4
</span><span class="gi">+  FSW %42:fpr32, %6:gpr, 0
+  %4:gpr = nuw nsw ADDI %4:gpr, 1
+  %3:gpr = ADDI %3:gpr, 4
+  BEQ %4:gpr, %32:gpr, %bb.4
</span>   PseudoBR %bb.3

 bb.6 (%ir-block.21):
   successors: %bb.5(0x04000000), %bb.6(0x7c000000);
               %bb.5(3.12%), %bb.6(96.88%)
<span class="gd">-  %14:fpr32 = COPY %42:fpr32
-  %13:gpr = COPY %41:gpr
-  %12:gpr = COPY %40:gpr
-  %30:fpr32 = FLW %12:gpr, 0
-  %31:fpr32 = FLW %13:gpr, 0
-  %15:fpr32 = nofpexcept FMADD_S %30:fpr32,
</span>               %31:fpr32, %14:fpr32, 7, implicit $frm
<span class="gd">-  %16:gpr = ADDI %13:gpr, 256
-  %17:gpr = ADDI %12:gpr, 4
-  %40:gpr = COPY %17:gpr
-  %41:gpr = COPY %16:gpr
-  %42:fpr32 = COPY %15:fpr32
-  BEQ %16:gpr, %5:gpr, %bb.5
</span><span class="gi">+  %30:fpr32 = FLW %40:gpr, 0
+  %31:fpr32 = FLW %41:gpr, 0
+  %42:fpr32 = nofpexcept FMADD_S %30:fpr32,
</span>               %31:fpr32, %42:fpr32, 7, implicit $frm
<span class="gi">+  %41:gpr = ADDI %41:gpr, 256
+  %40:gpr = ADDI %40:gpr, 4
+  BEQ %41:gpr, %5:gpr, %bb.5
</span>   PseudoBR %bb.6</code></pre>
        <p>
          The purpose of the instruction scheduler, <mark>machine-scheduler</mark>, is to re-order instructions to minimize hazards and stalls. The exact schedule depends on micro-architectural details, and an example of a scheduler descriptor file is <a href="https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/RISCV/RISCVSchedSiFive7.td">RISCVSchedSiFive7.td</a> for the SiFive 7 CPU. In our invocation of Clang, we did not specify a particular CPU, so some generic information for RISC-V is used. Its operation is shown in the following diff:
        </p>
        <pre><code class="highlight"> bb.0 (%ir-block.3):
   successors: %bb.1(0x80000000); %bb.1(100.00%)
   liveins: $x10, $x11, $x12
   %20:gpr = COPY $x12
   %19:gpr = COPY $x11
   %0:gpr = COPY $x10
<span class="gi">+  %1:gpr = COPY $x0
</span>   %27:gpr = LUI 4
   %32:gpr = ADDI $x0, 64
<span class="gd">-  %1:gpr = COPY $x0
</span>
 bb.1 (%ir-block.4):
   successors: %bb.3(0x80000000); %bb.3(100.00%)
<span class="gi">+  %4:gpr = COPY $x0
</span>   %2:gpr = nuw nsw SLLI %1:gpr, 6
   %3:gpr = COPY %19:gpr
<span class="gd">-  %4:gpr = COPY $x0
</span>   PseudoBR %bb.3

 bb.2 (%ir-block.7):
   PseudoRET

 bb.3 (%ir-block.8):
   successors: %bb.6(0x80000000); %bb.6(100.00%)
<span class="gd">-  %25:gpr = nuw nsw SLLI %4:gpr, 2
-  %26:gpr = ADD %25:gpr, %19:gpr
-  %5:gpr = ADD %26:gpr, %27:gpr
</span>   %28:gpr = OR %4:gpr, %2:gpr
   %29:gpr = SLLI %28:gpr, 2
   %6:gpr = ADD %20:gpr, %29:gpr
   %42:fpr32 = FLW %6:gpr, 0
<span class="gi">+  %25:gpr = nuw nsw SLLI %4:gpr, 2
+  %26:gpr = ADD %25:gpr, %19:gpr
+  %5:gpr = ADD %26:gpr, %27:gpr
</span>   %40:gpr = COPY %0:gpr
   %41:gpr = COPY %3:gpr
   PseudoBR %bb.6

 bb.4 (%ir-block.15):
   successors: %bb.2(0x04000000), %bb.1(0x7c000000);
               %bb.2(3.12%), %bb.1(96.88%)
   %1:gpr = nuw nsw ADDI %1:gpr, 1
   %0:gpr = ADDI %0:gpr, 256
   BEQ %1:gpr, %32:gpr, %bb.2
   PseudoBR %bb.1

 bb.5 (%ir-block.18):
   successors: %bb.4(0x04000000), %bb.3(0x7c000000);
               %bb.4(3.12%), %bb.3(96.88%)
   FSW %42:fpr32, %6:gpr, 0
   %4:gpr = nuw nsw ADDI %4:gpr, 1
   %3:gpr = ADDI %3:gpr, 4
   BEQ %4:gpr, %32:gpr, %bb.4
   PseudoBR %bb.3

 bb.6 (%ir-block.21):
   successors: %bb.5(0x04000000), %bb.6(0x7c000000);
               %bb.5(3.12%), %bb.6(96.88%)
   %30:fpr32 = FLW %40:gpr, 0
   %31:fpr32 = FLW %41:gpr, 0
   %42:fpr32 = nofpexcept FMADD_S %30:fpr32, %31:fpr32,
               %42:fpr32, 7, implicit $frm
   %41:gpr = ADDI %41:gpr, 256
   %40:gpr = ADDI %40:gpr, 4
   BEQ %41:gpr, %5:gpr, %bb.5
   PseudoBR %bb.6</code></pre>
        <p>
          We're now ready to run the <mark>greedy</mark> register allocator †, whose purpose is to assign every virtual register a physical register, while re-using the limited number of physical registers on the machine, and minimizing register spills. The actual replacement is done by the <mark>virtregrewriter</mark> pass:
        </p>
        <pre><code class="highlight"> Function Live Ins: $x10, $x11, $x12

 bb.0 (%ir-block.3):
   successors: %bb.1(0x80000000); %bb.1(100.00%)
   liveins: $x10, $x11, $x12
<span class="gd">-  %20:gpr = COPY $x12
-  %19:gpr = COPY $x11
-  %0:gpr = COPY $x10
-  %1:gpr = COPY $x0
-  %27:gpr = LUI 4
-  %32:gpr = ADDI $x0, 64
</span><span class="gi">+  renamable $x16 = COPY $x0
+  renamable $x17 = LUI 4
+  renamable $x5 = ADDI $x0, 64
</span>
 bb.1 (%ir-block.4):
   successors: %bb.3(0x80000000); %bb.3(100.00%)
<span class="gd">-  %4:gpr = COPY $x0
-  %2:gpr = nuw nsw SLLI %1:gpr, 6
-  %3:gpr = COPY %19:gpr
</span><span class="gi">+  liveins: $x5, $x10, $x11, $x12, $x16, $x17
+  renamable $x29 = COPY $x0
+  renamable $x6 = nuw nsw SLLI renamable $x16, 6
+  renamable $x28 = COPY renamable $x11
</span>   PseudoBR %bb.3

 bb.2 (%ir-block.7):
 ; predecessors: %bb.4

   PseudoRET

 bb.3 (%ir-block.8):
   successors: %bb.6(0x80000000); %bb.6(100.00%)
<span class="gd">-  %28:gpr = OR %4:gpr, %2:gpr
-  %29:gpr = SLLI %28:gpr, 2
-  %6:gpr = ADD %20:gpr, %29:gpr
-  %42:fpr32 = FLW %6:gpr, 0
-  %25:gpr = nuw nsw SLLI %4:gpr, 2
-  %26:gpr = ADD %25:gpr, %19:gpr
-  %5:gpr = ADD %26:gpr, %27:gpr
-  %40:gpr = COPY %0:gpr
-  %41:gpr = COPY %3:gpr
</span><span class="gi">+  liveins: $x5, $x6, $x10, $x11, $x12, $x16, $x17, $x28, $x29
+  renamable $x13 = OR renamable $x29, renamable $x6
+  renamable $x13 = SLLI killed renamable $x13, 2
+  renamable $x7 = ADD renamable $x12, killed renamable $x13
+  renamable $f15_f = FLW renamable $x7, 0
+  renamable $x13 = nuw nsw SLLI renamable $x29, 2
+  renamable $x13 = ADD killed renamable $x13, renamable $x11
+  renamable $x14 = ADD killed renamable $x13, renamable $x17
+  renamable $x15 = COPY renamable $x10
+  renamable $x13 = COPY renamable $x28
</span>   PseudoBR %bb.6

 bb.4 (%ir-block.15):
   successors: %bb.2(0x04000000), %bb.1(0x7c000000);
               %bb.2(3.12%), %bb.1(96.88%)
<span class="gd">-  %1:gpr = nuw nsw ADDI %1:gpr, 1
-  %0:gpr = ADDI %0:gpr, 256
-  BEQ %1:gpr, %32:gpr, %bb.2
</span><span class="gi">+  liveins: $x5, $x10, $x11, $x12, $x16, $x17
+  renamable $x16 = nuw nsw ADDI killed renamable $x16, 1
+  renamable $x10 = ADDI killed renamable $x10, 256
+  BEQ renamable $x16, renamable $x5, %bb.2
</span>   PseudoBR %bb.1

 bb.5 (%ir-block.18):
   successors: %bb.4(0x04000000), %bb.3(0x7c000000);
               %bb.4(3.12%), %bb.3(96.88%)
<span class="gd">-  FSW %42:fpr32, %6:gpr, 0
-  %4:gpr = nuw nsw ADDI %4:gpr, 1
-  %3:gpr = ADDI %3:gpr, 4
-  BEQ %4:gpr, %32:gpr, %bb.4
</span><span class="gi">+  liveins: $x5, $x6, $x7, $x10, $x11, $x12, $x16,
</span>            $x17, $x28, $x29, $f15_f
<span class="gi">+  FSW killed renamable $f15_f, killed renamable $x7, 0
+  renamable $x29 = nuw nsw ADDI killed renamable $x29, 1
+  renamable $x28 = ADDI killed renamable $x28, 4
+  BEQ renamable $x29, renamable $x5, %bb.4
</span>   PseudoBR %bb.3

 bb.6 (%ir-block.21):
   successors: %bb.5(0x04000000), %bb.6(0x7c000000);
               %bb.5(3.12%), %bb.6(96.88%)
<span class="gd">-  %30:fpr32 = FLW %40:gpr, 0
-  %31:fpr32 = FLW %41:gpr, 0
-  %42:fpr32 = nofpexcept FMADD_S %30:fpr32, %31:fpr32,
</span>               %42:fpr32, 7, implicit $frm
<span class="gd">-  %41:gpr = ADDI %41:gpr, 256
-  %40:gpr = ADDI %40:gpr, 4
-  BEQ %41:gpr, %5:gpr, %bb.5
</span><span class="gi">+  liveins: $x5, $x6, $x7, $x10, $x11, $x12, $x13, $x14,
</span>            $x15, $x16, $x17, $x28, $x29, $f15_f
<span class="gi">+  renamable $f14_f = FLW renamable $x15, 0
+  renamable $f13_f = FLW renamable $x13, 0
+  renamable $f15_f = nofpexcept FMADD_S killed renamable $f14_f,
</span>                      killed renamable $f13_f, killed renamable $f15_f,
                      7, implicit $frm
<span class="gi">+  renamable $x13 = ADDI killed renamable $x13, 256
+  renamable $x15 = ADDI killed renamable $x15, 4
+  BEQ renamable $x13, renamable $x14, %bb.5
</span>   PseudoBR %bb.6</code></pre>
        <p>
          Before we emit the assembly, there are two pending steps: first, the basic blocks need to be re-ordered, so that the final structure is flat and there are no unnecessary jumps; second, the pseudo-instructions like COPY need to be replaced by real instructions. The final MIR after the <mark>branch-folder</mark> and <mark>postrapseduos</mark> passes is:
        </p>
        <pre><code class="highlight"> Function Live Ins: $x10, $x11, $x12

 bb.0 (%ir-block.3):
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $x10, $x11, $x12
  $x16 = ADDI $x0, 0
  renamable $x17 = LUI 4
  renamable $x5 = ADDI $x0, 64

bb.1 (%ir-block.4):
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x5, $x10, $x11, $x12, $x16, $x17
  $x29 = ADDI $x0, 0
  renamable $x6 = nuw nsw SLLI renamable $x16, 6
  $x28 = ADDI $x11, 0

bb.2 (%ir-block.8):
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  liveins: $x5, $x6, $x10, $x11, $x12, $x16, $x17, $x28, $x29
  renamable $x13 = OR renamable $x29, renamable $x6
  renamable $x13 = SLLI killed renamable $x13, 2
  renamable $x7 = ADD renamable $x12, killed renamable $x13
  renamable $f15_f = FLW renamable $x7, 0
  renamable $x13 = nuw nsw SLLI renamable $x29, 2
  renamable $x13 = ADD killed renamable $x13, renamable $x11
  renamable $x14 = ADD killed renamable $x13, renamable $x17
  $x15 = ADDI $x10, 0
  $x13 = ADDI $x28, 0

bb.3 (%ir-block.21):
  successors: %bb.4(0x04000000), %bb.3(0x7c000000);
              %bb.4(3.12%), %bb.3(96.88%)
  liveins: $x5, $x6, $x7, $x10, $x11, $x12, $x13, $x14,
           $x15, $x16, $x17, $x28, $x29, $f15_f
  renamable $f14_f = FLW renamable $x15, 0
  renamable $f13_f = FLW renamable $x13, 0
  renamable $f15_f = nofpexcept FMADD_S killed renamable $f14_f,
                     killed renamable $f13_f, killed renamable $f15_f,
                     7, implicit $frm
  renamable $x13 = ADDI killed renamable $x13, 256
  renamable $x15 = ADDI killed renamable $x15, 4
  BNE renamable $x13, renamable $x14, %bb.3

bb.4 (%ir-block.18):
  successors: %bb.5(0x04000000), %bb.2(0x7c000000);
              %bb.5(3.12%), %bb.2(96.88%)
  liveins: $x5, $x6, $x7, $x10, $x11, $x12, $x16, $x17, $x28, $x29, $f15_f
  FSW killed renamable $f15_f, killed renamable $x7, 0
  renamable $x29 = nuw nsw ADDI killed renamable $x29, 1
  renamable $x28 = ADDI killed renamable $x28, 4
  BNE renamable $x29, renamable $x5, %bb.2

bb.5 (%ir-block.15):
  successors: %bb.6(0x04000000), %bb.1(0x7c000000);
              %bb.6(3.12%), %bb.1(96.88%)
  liveins: $x5, $x10, $x11, $x12, $x16, $x17
  renamable $x16 = nuw nsw ADDI killed renamable $x16, 1
  renamable $x10 = ADDI killed renamable $x10, 256
  BNE renamable $x16, renamable $x5, %bb.1

bb.6 (%ir-block.7):
  PseudoRET</code></pre>
        <p>
          The final assembly is produced by AsmPrinter, which doesn't do much more than pretty-printing registers (<mark>$x10</mark> is <mark>a0</mark>, <mark>$x11</mark> is <mark>a1</mark>), and instructions (<mark>FMADD_S</mark> is <mark>fmadd.s</mark>, <mark><mjx-container class="MathJax" jax="CHTML" style="font-size: 113.1%;"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c36"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="4"><mjx-c class="mjx-c1D434 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43C TEX-I"></mjx-c></mjx-mi></mjx-math></mjx-container>x0, 0</mark> is <mark>li a6, 0</mark>), dropping auxiliary information. This output can be checked against the <a href="https://github.com/riscv/riscv-isa-manual/">RISC-V ISA manual</a>.
        </p>
        <pre><code class="highlight">matmul:                                 # @matmul
# %bb.0:
  li a6, 0
  lui   a7, 4
  li t0, 64
.LBB0_1:                                # =&gt;This Loop Header: Depth=1
                                        #     Child Loop BB0_2 Depth 2
                                        #       Child Loop BB0_3 Depth 3
  li t4, 0
  slli  t1, a6, 6
  mv t3, a1
.LBB0_2:                                #   Parent Loop BB0_1 Depth=1
                                        # =&gt;  This Loop Header: Depth=2
                                        #       Child Loop BB0_3 Depth 3
  or a3, t4, t1
  slli  a3, a3, 2
  add   t2, a2, a3
  flw   fa5, 0(t2)
  slli  a3, t4, 2
  add   a3, a3, a1
  add   a4, a3, a7
  mv a5, a0
  mv a3, t3
.LBB0_3:                                #   Parent Loop BB0_1 Depth=1
                                        #     Parent Loop BB0_2 Depth=2
                                        # =&gt;    This Inner Loop Header: Depth=3
  flw   fa4, 0(a5)
  flw   fa3, 0(a3)
  fmadd.s fa5, fa4, fa3, fa5
  addi  a3, a3, 256
  addi  a5, a5, 4
  bne   a3, a4, .LBB0_3
# %bb.4:                                #   in Loop: Header=BB0_2 Depth=2
  fsw   fa5, 0(t2)
  addi  t4, t4, 1
  addi  t3, t3, 4
  bne   t4, t0, .LBB0_2
# %bb.5:                                #   in Loop: Header=BB0_1 Depth=1
  addi  a6, a6, 1
  addi  a0, a0, 256
  bne   a6, t0, .LBB0_1
# %bb.6:
  ret</code></pre>
        <footer>
          <ul class="footer">
            <li>
              There is an alternative instruction selection framework called GlobalISel, and alternative register allocation algorithms in LLVM.
            </li>
          </ul>
        </footer>
      </article>
    </main>
  </body>
</html>