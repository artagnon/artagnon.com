<!DOCTYPE html>
<html lang="en">
  <head>
    <title>The type theory | artagnon.com</title>
    <meta charset="utf-8" />
    <meta name="description" content="Ramkumar Ramachandra&#39;s personal website" />
    <meta name="HandheldFriendly" content="true" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index,follow" />
    <link rel="icon" href="/dist/artagnon.com.svg" />
    <link rel="mask-icon" href="/dist/mask-icon.svg" color="#000000" />
    <link rel="stylesheet" href="/dist/style.min.css" />
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/cash/6.0.1/cash.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.35/dayjs.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.35/plugin/relativeTime.min.js"></script>
    <script defer="" src="//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
    <script>
      MathJax = {
        loader: {
          load: ['[custom]/xypic.js'],
          paths: {custom: '/lib'}
        },
        tex: {
          packages: {'[+]': ['xypic']},
          inlineMath: [['$', '$']]
        },
        chtml: {
          fontURL: "/dist/woff"
        },
        startup: {
          elements: [".mathjax", "li > a", "h1", "h2", "h3"]
        }
      };
    </script>
    <link rel="preload" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/solarized-light.min.css" as="style" onload="this.onload=null;this.rel=&#39;stylesheet&#39;" />
    <noscript>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/solarized-light.min.css" />
    </noscript>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/coq.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/cpp.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/haskell.min.js"></script>
    <script defer="" src="/dist/script.min.js"></script>
  </head>
  <body>
    <nav>
      <div>
        <a href="/"><img src="/dist/artagnon.com.svg" alt="home" /></a>
      </div>
      <div>
        <ul>
          <li>
            <a href="/articles">articles</a>
          </li>
          <li>
            <a href="/computing">computing</a>
          </li>
          <li>
            <a href="/math">math</a>
          </li>
        </ul>
      </div>
    </nav>
    <main>
      <header>
        <h1>
          The type theory
        </h1>
        <div id="metadata">
          <span id="timestamp"><time datetime="2020-05-27" class="begin">Wed, 27 May 2020 12:24:05 +0200</time><span class="to">↪</span><time datetime="2021-02-21" class="end">Sun, 21 Feb 2021 16:31:11 +0100</time></span><br /><span id="locations"><address>Paris</address></span>
        </div>
      </header>
      <article class="wrapper">
        <p class="blurb">
          This brief exposé lays the foundations for studying homotopy type theory; the concepts from here will re-appear in <a href="/HoTT/2">HoTT/2</a>, with fresh interpretations. It corresponds exactly to Ch.1 of the HoTT book.
        </p>
        <p>
          To specify a new type in HoTT, we need to specify four different rules: formation, introduction, elimintion, computation (FIEC).
        </p>
        <ol class="olitems" type="i" start="1">
          <li>
            How to form a new type of this kind. For example <span class="mathjax">$\Pi_{(x : A)} B(x)$</span>
          </li>
          <li>
            How to construct elements of this kind. For example, a function type has one constructor: <span class="mathjax">$f(x) :\equiv 2x$</span>.
          </li>
          <li>
            How to use elements of this type. These are called eliminators or <mark>elimination rules</mark>. For instance, a function type has one eliminator, namely function application.
          </li>
          <li>
            How the eliminator acts on the constructor. For example, <span class="mathjax">$(\lambda x . \phi)(a)$</span> is judgementally equal to the expanded function <span class="mathjax">$\lambda f . f(x)$</span>.
          </li>
          <li>
            An optional uniqueness principle which expresses uniqueness into or out of the type. Every element of the type is uniquely determined by results of applying type eliminators to it. It is often a provable propositional equality: in this case, we call it <mark>propositional uniqueness principle</mark>.
          </li>
        </ol>
        <p>
          Broadly speaking, there are two kinds of types: <span class="mathjax">$\Pi$</span> (which turns out to be a degenerate case of an inductive type, which we will see later) and <span class="mathjax">$\Sigma$</span>.
        </p>
        <h2 id="the-dependent-product-type-pi-type">
          The dependent product type ($\Pi$-type)
        </h2>
        <p>
          Instead of defining projections <span class="mathjax">$pr1$</span> and <span class="mathjax">$pr2$</span> for the two projections from the pair, we will define a "recursor" as follows:
        </p>
        <div class="mathjax">
          $$
          rec_{A \times B} : \Pi_{C : \mathscr{U}} (A \times B \times C) \rightarrow A \times B \rightarrow C \\
            rec_{A \times B}(C, g, (a, b)) :\equiv g(a)(b)
          $$
        </div>
        <p>
          So that:
        </p>
        <div class="mathjax">
          $$
          pr1 :\equiv rec_{A \times B}(A, \lambda a . \lambda b . a) \\
            pr2 :\equiv rec_{A \times B}(B, \lambda a . \lambda b . b)
          $$
        </div>
        <p>
          In order to be able to write dependent functions over the product type, we can define function <span class="mathjax">$f : \Pi_{x : A \times B} C(x)$</span> by providing <span class="mathjax">$g : \Pi_{x : A} \Pi_{x : B} C((x, y))$</span> with the defining equation <span class="mathjax">$f((x, y)) = g(x)(y)$</span>.
        </p>
        <p>
          To prove a property for all elements of a prduct, it is enough to prove it for its canonical elements (the ordered pairs). In the universal case, we call the resulting function induction for product types:
        </p>
        <div class="mathjax">
          $$
          ind_{A \times B} : \Pi_{C : A \times B \rightarrow U} (\Pi_{x : A}\Pi_{y : B} C((x, y))) \rightarrow \Pi_{x : A \rightarrow B} C(x)
          $$
        </div>
        <p>
          with the defining equation:
        </p>
        <div class="mathjax">
          $$
          ind_{A \times B}(C, g, (a, b)) :\equiv g(a)(b)
          $$
        </div>
        <p>
          Because induction describes how to use an element of the product type, induction is often called the <mark>dependent eliminator</mark>; recursion is called the <mark>non-dependent eliminator</mark>.
        </p>
        <p>
          Comment: the induction for the unit type turns out to be more useful than the recursor:
        </p>
        <div class="mathjax">
          $$
          uniq_1 : \Pi_{x : \mathbf{1}} x = \star \\
            uniq_1(x) :\equiv refl_\star
          $$
        </div>
        <h2 id="the-dependent-pair-type-sigma-type">
          The dependent pair type ($\Sigma$-type)
        </h2>
        <p>
          The dependent pair type is written <span class="mathjax">$\Sigma_{x : A}, B(x)$</span>. When the second component doesn't depend on the first, we get the cartesian product type <span class="mathjax">$A \times B$</span>. The first projection follows a straightforward extraction:
        </p>
        <div class="mathjax">
          $$
          pr1 : (\Sigma_{x : A} B(x)) \rightarrow A
          $$
        </div>
        <p>
          However, the second projection must be a dependent function, whose type involves the first projection function:
        </p>
        <div class="mathjax">
          $$
          pr2 : \Pi_{p: \Sigma_{x : A} B(x)} B(pr1(p))
          $$
        </div>
        <p>
          Thus, we need the induction principle for <span class="mathjax">$\Sigma$</span>-types (the <mark>dependent eliminator</mark>):
        </p>
        <div class="mathjax">
          $$
          g : \Pi_{a : A}\Pi_{b : B(a)} C((a, b))
          $$
        </div>
        <p>
          We can then derive a function:
        </p>
        <div class="mathjax">
          $$
          f : \Pi_{p:\Sigma_{x : A}, B(x)} C(p)
          $$
        </div>
        <p>
          In order to package up the recursion and induction principles into a recursor for <span class="mathjax">$\Sigma$</span>, which we will not bother elaborating here. As usual, the recursor is the special case of induction when the family <span class="mathjax">$C$</span> is fixed.
        </p>
        <p>
          Now, we present the <mark>type-theoretic axiom of choice</mark> where <span class="mathjax">$R : A \rightarrow B \rightarrow U$</span>:
        </p>
        <div class="mathjax">
          $$
          ac : (\Pi_{a : A} \Sigma_{y : B} R(x, y)) \rightarrow (\Sigma_{f : A \rightarrow B} \Pi_{x : A} R(x, f(x))) \\
            ac(g) :\equiv (\lambda x . pr_1(g(x)), \lambda x . pr2(g(x)) \\
            \lambda x . pr_1(g(x)) : A \rightarrow B \\
            \lambda x . pr_2(g(x)) : \Pi_{x : A} R(x, pr_1(g(x)))
          $$
        </div>
        <p>
          In English, this reads: if <span class="mathjax">$\forall x : A$</span>, there is a <span class="mathjax">$y : B$</span> such that <span class="mathjax">$R(x, y)$</span>, then <span class="mathjax">$\exists f : A \rightarrow B$</span> such that <span class="mathjax">$\forall x : A$</span>, we have <span class="mathjax">$R(x, f(x))$</span>. We will provide a more familar axiom of choice later.
        </p>
        <p>
          Let's also provide an example of the magma type, in which the second component depends on the first component:
        </p>
        <div class="mathjax">
          $$
          Magma :\equiv \Sigma_{A : \mathscr{U}} A \rightarrow A \rightarrow A
          $$
        </div>
        <h2 id="interlude-coproduct-types-and-booleans">
          Interlude: Coproduct types and booleans
        </h2>
        <p>
          The recursor for coproduct types can be written as:
        </p>
        <div class="mathjax">
          $$
          rec_{A + B} : \Pi_{C : \mathscr{U}} (A \rightarrow C) \rightarrow (B \rightarrow C) \rightarrow A + B \rightarrow C \\
            rec_{A + B}(C, g_0, g_1, inl(a)) :\equiv g_0(a) \\
            rec_{A + B}(\Pi_{C : \mathscr{U}} (C, g_0, g_1, inr(a)) :\equiv g_1(a)
          $$
        </div>
        <p>
          The if-then-else pattern in general programming practice utilizes booleans as follows:
        </p>
        <div class="mathjax">
          $$
          rec_2 : \Pi_{C : \mathscr{U}} C \rightarrow C \rightarrow \mathbf{2} \rightarrow C \\
            rec_2(C, c_0, c_1, 0_\mathbb{2}) :\equiv c_0 \\
            rec_2(C, c_0, c_1, 1_\mathbb{2}) :\equiv c_1
          $$
        </div>
        <h2 id="mathbb-n-and-primitive-recursion">
          $\mathbb{N}$ and primitive recursion
        </h2>
        <p>
          To define infinite types like <span class="mathjax">$\mathbb{N}$</span>, we need the additional concept of well-founded recursion. We can package the recursor into a single function, as previously:
        </p>
        <div class="mathjax">
          $$
          rec_\mathbb{N} : \Pi_{C : \mathscr{U}} C \rightarrow (\mathbb{N} \rightarrow C \rightarrow C) \rightarrow \mathbb{N} \rightarrow C
          $$
        </div>
        <p>
          Given step 0, and a next-step function, we can define:
        </p>
        <div class="mathjax">
          $$
          rec_{\mathbb{N}}(C, c_0, c_s, 0) = c_0 \\
            rec_{\mathbb{N}}(C, c_0, c_s, succ(n)) = c_s(n, rec_\mathbb{N}(C, c_0, c_s, n))
          $$
        </div>
        <p>
          We can generalize general recursion to dependent functions as follows:
        </p>
        <div class="mathjax">
          $$
          ind_{\mathbb{N}} : \Pi_{C : \mathbb{N} \rightarrow U} C(0) \rightarrow (\Pi_{n : \mathbb{N}} C(n) \rightarrow C(succ(n))) \rightarrow \Pi_{n \in \mathbb{N}} C(n)
          $$
        </div>
        <p>
          with these defining equations:
        </p>
        <div class="mathjax">
          $$
          f(0) :\equiv c_0 \\
            f(succ(n)) :\equiv c_s(n, f(n))
          $$
        </div>
        <h2 id="identity-types">
          Identity types
        </h2>
        <p>
          The cornerstone of homotopy type theory is that there can be more than one witness that two objects are equal. These correspond to paths or equivalences in the given space.
        </p>
        <p>
          The identity family takes two copies of <span class="mathjax">$A$</span>, and illustrates an equality between them: <span class="mathjax">$id_A : A \rightarrow A \rightarrow \mathscr{U}$</span>. The formation rule says that given a type <span class="mathjax">$A : \mathscr{U}$</span> and two elements <span class="mathjax">$a, b : A$</span>, we can form the type <span class="mathjax">$(a =_A b) : \mathscr{U}$</span> in the same universe. The introduction rule is a dependent function called reflexivity:
        </p>
        <div class="mathjax">
          $$
          \texttt{refl} : \Pi_{a : A} a = a
          $$
        </div>
        <p>
          The elimination rule for identity types is subtle. We begin by considering the consequence that equals may be substituted for equals, called <mark>indiscrenability of identicals</mark>. For every family <span class="mathjax">$C : A \rightarrow \mathscr{U}$</span>, there is a function
        </p>
        <div class="mathjax">
          $$
          f : \Pi_{x, y : A} \Pi_{x =_A y} C(x) \rightarrow C(y)
          $$
        </div>
        <p>
          such that:
        </p>
        <div class="mathjax">
          $$
          f(x, x, \texttt{refl}_x) :\equiv id_{C(x)}
          $$
        </div>
        <h2 id="path-induction">
          Path induction
        </h2>
        <p>
          The induction principle for the identity type is called <mark>path induction</mark>. It can be seen as stating that the family of identity types is freely generated by elements of the form <span class="mathjax">$\texttt{refl}_x : x = x$</span>.
        </p>
        <p>
          Given functions:
        </p>
        <div class="mathjax">
          $$
          C : \Pi_{x, y : A} (x =_A y) \rightarrow \mathscr{U} \\
            c : \Pi_{x : A} C(x, x, \texttt{refl}_x)
          $$
        </div>
        <p>
          There is a function:
        </p>
        <div class="mathjax">
          $$
          f : \Pi_{x, y : A} \Pi_{p : x =_A y} C(x, y, p)
          $$
        </div>
        <p>
          such that
        </p>
        <div class="mathjax">
          $$
          f(x, x, \texttt{refl}_x) :\equiv c(x)
          $$
        </div>
        <p>
          We can conclude that <span class="mathjax">$C(x, y)$</span> is a reflexive relation that holds whenever <span class="mathjax">$x = y$</span>.
        </p>
        <p>
          If we package up path induction into a single function, it takes the form:
        </p>
        <div class="mathjax">
          $$
          ind_{=A} : \Pi_{C : \Pi_{x, y : A} (x =_A y) \rightarrow \mathscr{U}} (\Pi_{x : A} C(x, x, \texttt{refl}_x)) \rightarrow \Pi_{x, y : A} \Pi_{p : x =_A y} C(x, y, p)
          $$
        </div>
        <p>
          with the equality, traditionally called <span class="mathjax">$J$</span>:
        </p>
        <div class="mathjax">
          $$
          ind_{=A}(C, c, x, x, \texttt{refl}_x) :\equiv c(x)
          $$
        </div>
        <p>
          Indiscrenability of identicals is an instance of path induction, as we will show later.
        </p>
        <p>
          By fixing a certain <span class="mathjax">$a : A$</span>, we can show <mark>based path induction</mark>, a simpler version:
        </p>
        <div class="mathjax">
          $$
          ind'_{=A} : \Pi_{a : A}\Pi_{C : \Pi_{a : A} (a =_A x) \rightarrow \mathscr{U}} C(a, \texttt{refl}_a) \rightarrow \Pi_{x : A} \Pi_{p : a =_A x} C(x, p)
          $$
        </div>
        <p>
          Since every path is of the form <span class="mathjax">$\texttt{refl}_a$</span>, if we prove a property for reflexivity paths, then we have provided it for all paths.
        </p>
        <p>
          Now, we must resolve a question: how can there be many different elements of the identity type (different paths), but also have an induction principle asserting that the only path is reflexivity? It is not that the identity type that is inductively defined; rather, it is the inductive family. In particular, path induction says that the family of types <span class="mathjax">$x =_A y$</span>, as <span class="mathjax">$x$</span> and <span class="mathjax">$y$</span> vary over all elements of <span class="mathjax">$A$</span>, inductively defined by the elements of the form <span class="mathjax">$\texttt{refl}_x$</span>. This means that to give an element of any other family, it suffices to consider the cases of the form <span class="mathjax">$(x, y, p)$</span> dependent on a generic element <span class="mathjax">$(x, y, p)$</span> of the identity family, it suffices to consider the cases of the form <span class="mathjax">$(x, x, \texttt{refl}_x)$</span>.
        </p>
        <p>
          In the homotopy interpretation, type of triples <span class="mathjax">$(x, y, p)$</span>, where <span class="mathjax">$x, y$</span> are endpoints of the path <span class="mathjax">$p$</span> (in other words, <span class="mathjax">$\Sigma_{x, y : A} (x = y)$</span>), is inductively generated by the constant loops at each point <span class="mathjax">$x$</span>. We will consequently see that that the space corresponding to <span class="mathjax">$\Sigma_{x, y : A} (x = y)$</span> is a <mark>free path space</mark>. To conclude, <span class="mathjax">$\Sigma_{y : A} (a = y)$</span> can be regarded as the type of all elements of <span class="mathjax">$A$</span> which are equal to <span class="mathjax">$a$</span>.
        </p>
      </article>
    </main>
  </body>
</html>