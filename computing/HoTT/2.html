<!DOCTYPE html>
<html lang="en">
  <head>
    <title>The essentials | artagnon.com</title>
    <meta charset="utf-8" />
    <meta name="description" content="Ramkumar Ramachandra&#39;s personal website" />
    <meta name="HandheldFriendly" content="true" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index,follow" />
    <link rel="icon" href="/dist/artagnon.com.svg" />
    <link rel="mask-icon" href="/dist/mask-icon.svg" color="#000000" />
    <link rel="stylesheet" href="/dist/style.min.css" />
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/cash/6.0.1/cash.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.35/dayjs.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.35/plugin/relativeTime.min.js"></script>
    <script defer="" src="//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
    <script>
      MathJax = {
        loader: {
          load: ['[custom]/xypic.js'],
          paths: {custom: '/lib'}
        },
        tex: {
          packages: {'[+]': ['xypic']},
          inlineMath: [['$', '$']]
        },
        chtml: {
          fontURL: "/dist/woff"
        }
      };
    </script>
    <link rel="preload" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/solarized-light.min.css" as="style" onload="this.onload=null;this.rel=&#39;stylesheet&#39;" />
    <noscript>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/solarized-light.min.css" />
    </noscript>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/coq.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/cpp.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/haskell.min.js"></script>
    <script defer="" src="/dist/script.min.js"></script>
  </head>
  <body>
    <nav>
      <div>
        <a href="/"><img src="/dist/artagnon.com.svg" alt="home" /></a>
      </div>
      <div>
        <ul>
          <li>
            <a href="/articles">articles</a>
          </li>
          <li>
            <a href="/computing">computing</a>
          </li>
          <li>
            <a href="/math">math</a>
          </li>
        </ul>
      </div>
    </nav>
    <main>
      <header>
        <h1>
          The essentials
        </h1>
        <div id="metadata">
          <span id="timestamp"><time datetime="2020-05-27" class="begin">Wed, 27 May 2020 12:24:05 +0200</time><span class="to">â†ª</span><time datetime="2021-02-21" class="end">Sun, 21 Feb 2021 16:31:11 +0100</time></span><br /><span id="locations"><address>Paris</address></span>
        </div>
      </header>
      <article class="wrapper">
        <p class="blurb">
          Here, we discuss concepts from Ch.2 of the HoTT book
        </p>
        <p>
          The central idea is that types can be interpreted as higher-dimensional groupoids in category theory, or spaces in homotopy theory. Space <span class="mathjax">$X$</span> is a set of points equipped with a topology, and a path betwen points <span class="mathjax">$x$</span> and <span class="mathjax">$y$</span> is represented by a continuous map <span class="mathjax">$p : [0, 1] \rightarrow X$</span> where <span class="mathjax">$p(0) = x, p(1) = y$</span>. The function can be thought of as giving a point <span class="mathjax">$x$</span> at each moment in time. A <mark>homotopy</mark> between a pair of continuous maps <span class="mathjax">$H : X_1 \times [0, 1] \rightarrow X_2$</span>, so that <span class="mathjax">$H(s, 0) = p(s)$</span> and <span class="mathjax">$H(s, 1) = q(s)$</span>, can be thought of as a continuous deformation from <span class="mathjax">$p$</span> to <span class="mathjax">$q$</span>.
        </p>
        <p>
          The <mark>fundamental group</mark> of a fundamental <span class="mathjax">$\infty$</span>-groupoid of a space will agree with the classical definition of a fundamental group of the space: this correspondence illustrates how homotopy theory and higher-dimensional category theory are intimately related.
        </p>
        <p>
          We will refer to <span class="mathjax">$x =_A y$</span> as a path between the <mark>start point</mark> <span class="mathjax">$x$</span> and <mark>endpoint</mark> <span class="mathjax">$y$</span>. <span class="mathjax">$r : p =_{x =_A y} q$</span> can be thought of as a homotopy or a 2-path or 2-dimensional path. All of the basic constructions and axoims arises automatically from the induction principle for identity types. In other words, given the dependent funtions:
        </p>
        <ol class="olitems" type="i" start="1">
          <li>
            <span class="mathjax">$D : \Pi_{x, y : A} (x = y) \rightarrow \mathscr{U}$</span>
          </li>
          <li>
            <span class="mathjax">$d : \Pi_{a : A} D(a, a, \texttt{refl}_a)$</span>
          </li>
        </ol>
        <p>
          there is a dependent function:
        </p>
        <div class="mathjax">
          $$
          ind_{=A}(D, d) : \Pi_{x, y : A} \Pi_{p : x = y} D(x, y, p)
          $$
        </div>
        <p>
          such that
        </p>
        <div class="mathjax">
          $$
          ind_{=A}(D, d, a, a, \texttt{refl}_a) \equiv d(a)
          $$
        </div>
        <p>
          Informally, the induction principle for identity types says that if we want to construct an object which depends on an inhabitant <span class="mathjax">$p : x =_A y$</span> of an identity type, then it suffices to perform the construction in the special case when <span class="mathjax">$x, y$</span> are judgementally the same, and <span class="mathjax">$p$</span> is the reflexivity element <span class="mathjax">$\texttt{refl}_x x = x$</span>.
        </p>
        <p>
          The induction principle endows each type with the structure of an <span class="mathjax">$\infty$</span>-groupoid, and each function between two types with the structure of the an <span class="mathjax">$\infty$</span>-functor betwen two such groupoids.
        </p>
        <h2 id="types-are-higher-groupoids">
          Types are higher groupoids
        </h2>
        <p class="exercise">
          To state our first lemma:
        </p>
        <div class="mathjax">
          $$
          \Pi_{A : \mathscr{U}} \Pi_{x, y : A} (x = y) \rightarrow (y = x)
          $$
        </div>
        <p>
          The proof of this lemma would involve constructing an inhabitant of this type. Let us write the proof in an informal style, as this is preferred. We want to construct <span class="mathjax">$x, y :A$</span>, <span class="mathjax">$p : x = y$</span>, and <span class="mathjax">$p^{-1} : y = x$</span>. By induction, it suffices to consider the case when <span class="mathjax">$y = x$</span> and <span class="mathjax">$p = \texttt{refl}_x$</span>. In this case, the type of <span class="mathjax">$x = y$</span> and <span class="mathjax">$y = x$</span>, in which we're trying to construct <span class="mathjax">$p^{-1}$</span>, are both equal to <span class="mathjax">$x = x$</span>. Thus, in the reflexivity case, we can define <span class="mathjax">$\texttt{refl}_x^{-1}$</span> to simply be <span class="mathjax">$\texttt{refl}_x$</span>. The general case therefore proceeds by the induction principle, and the conversion rule <span class="mathjax">$\texttt{refl}_x^{-1} \equiv \texttt{refl}_x$</span>.
        </p>
        <p class="exercise">
          To state our second lemma:
        </p>
        <div class="mathjax">
          $$
          \Pi_{A : \mathscr{U}} \Pi_{x, y, z : A} (x = y) \rightarrow (y = z) \rightarrow (x = z)
          $$
        </div>
        <p>
          The proof proceeds as follows: <span class="mathjax">$\forall x, y, z : A$</span>, every <span class="mathjax">$p : x = y$</span> and every <span class="mathjax">$q : y = z$</span>, we need to construct an inhabitant of <span class="mathjax">$x = z$</span>. By induction on <span class="mathjax">$p$</span>, it sufficces to assume that <span class="mathjax">$y = x$</span> and <span class="mathjax">$p$</span> is <span class="mathjax">$\texttt{refl}_x$</span>. In this case, the type of <span class="mathjax">$y = z$</span> of <span class="mathjax">$q$</span> is <span class="mathjax">$x = z$</span>. By induction on <span class="mathjax">$q$</span>, it suffices to assume that <span class="mathjax">$z = x$</span> and <span class="mathjax">$q$</span> is <span class="mathjax">$\texttt{refl}_x$</span>. In this case, <span class="mathjax">$x = z$</span> is <span class="mathjax">$x = x$</span>, and we have <span class="mathjax">$\texttt{refl}_x : (x = x)$</span>.
        </p>
        <p>
          This proof raises the question of why an induction on <span class="mathjax">$q$</span> is required at all, when we already have the equality <span class="mathjax">$x = z$</span>. Indeed, we could have done an induction on <span class="mathjax">$p$</span> yielding the computation rule <span class="mathjax">$p \circ \texttt{refl}_x \equiv p$</span>, an induction on <span class="mathjax">$q$</span> yielding the computation rule <span class="mathjax">$\texttt{refl}_y \circ q \equiv q$</span>, or, as above, induction on both <span class="mathjax">$p$</span> and <span class="mathjax">$q$</span>, yeilding <span class="mathjax">$\texttt{refl}_x \circ \texttt{refl}_x \equiv \texttt{refl}_x$</span>. We would merely have three different elements of the same type.
        </p>
        <p class="exercise">
          We will now state some results without the obvious proofs. For <span class="mathjax">$\Pi_{A : \mathscr{U}} \Pi_{x, y, z, w : A}$</span>, <span class="mathjax">$p : x = y$</span>, <span class="mathjax">$q : y = z$</span>, <span class="mathjax">$r : z = w$</span>:
        </p>
        <ol class="olitems" type="i" start="1">
          <li>
            <span class="mathjax">$p = p \circ \texttt{refl}_y$</span> and <span class="mathjax">$p = \texttt{refl}_x \circ p$</span>
          </li>
          <li>
            <span class="mathjax">$p^{-1} \circ p = \texttt{refl}_y$</span> and <span class="mathjax">$p \circ p^{-1} = \texttt{refl}_x$</span>
          </li>
          <li>
            <span class="mathjax">$(p^{-1})^{-1} = p$</span>
          </li>
          <li>
            <span class="mathjax">$(p \circ q) \circ r = p \circ (q \circ r)$</span>
          </li>
        </ol>
        <p>
          Given a type <span class="mathjax">$A$</span> with point <span class="mathjax">$a : A$</span>, we define its loop space <span class="mathjax">$\Omega(A, a)$</span> to be the type <span class="mathjax">$a =_A a$</span>; we could concatenate this to <span class="mathjax">$\Omega A$</span> if <span class="mathjax">$a$</span> is understood from the context. Since any two elements of <span class="mathjax">$\Omega A$</span> are paths with the same start and endpoints, we have <span class="mathjax">$\Omega A \times \Omega A \rightarrow \Omega A$</span>. It can also be fruitful to consider the loop space of a loop space of <span class="mathjax">$A$</span>, the space of 2-dimensional loops, written <span class="mathjax">$\Omega^2(A, a)$</span>, represented as <span class="mathjax">$\texttt{refl}_a =_{a =_A a} \texttt{refl}_a$</span>.
        </p>
        <p class="exercise">
          The Eckmann-Hilton theorem can be stated as <span class="mathjax">$\Omega^2(A) \times \Omega^2(A) \rightarrow \Omega^2(A)$</span> being commutative: <span class="mathjax">$\alpha \circ \beta = \beta \circ \alpha$</span> for any <span class="mathjax">$\alpha, \beta : \Omega^2(A)$</span>.
        </p>
        <p>
          First, notice that <span class="mathjax">$\Omega A \times \Omega A \rightarrow \Omega A$</span> induces an operation:
        </p>
        <div class="mathjax">
          $$
          \star : \Omega^2(A) \times \Omega^2(A) \rightarrow \Omega^2(A)
          $$
        </div>
        <p>
          In the following diagram,
        </p>
        <div class="mathjax">
          $$
          \begin{matrix}
              p : a = b & q : a = b \\
              r : b = c & s : b = c \\
              \alpha : p = q & \beta : r = s
            \end{matrix}
          $$
        </div>
        <div class="mathjax">
          $$
            \begin{xy}
            \xymatrix{
          
          & \ar@{=>}[dd]_\alpha && \ar@{=>}[dd]_\beta & \\
            a \ar@/^3pc/[rr]^p\ar@/_3pc/[rr]_q && b \ar@/^3pc/[rr]^r\ar@/_3pc/[rr]_s && c \\
            & & & &
            }
            \end{xy}
          
          $$
        </div>
        <p>
          Composing the two upper and lower paths, we get <span class="mathjax">$p \circ r, q \circ s : a = c$</span>. The horizontal composition can be written as <span class="mathjax">$\alpha \star \beta : p \circ r = q \circ s$</span> defined as follows. First, we define <span class="mathjax">$\alpha \circ_r r = p \circ_r = q \circ r$</span> by path induction on <span class="mathjax">$r$</span> so that
        </p>
        <div class="mathjax">
          $$
          \alpha \circ_r \texttt{refl}_b \equiv \texttt{ru}_p^{-1} \circ \alpha \circ \texttt{ru}_q
          $$
        </div>
        <p>
          where <span class="mathjax">$\texttt{ru}_p = p \circ \texttt{refl}_b$</span> is the right unit lemma, which we previously mentioned. We can also define <span class="mathjax">$q \circ_l \beta : q \circ r = q \circ s$</span> by induction on <span class="mathjax">$q$</span> so that
        </p>
        <div class="mathjax">
          $$
          \texttt{refl}_b \circ_l \beta \equiv \texttt{lu}_r^{-1} \circ \beta \circ \texttt{lu}_s
          $$
        </div>
        <p>
          where <span class="mathjax">$\texttt{lu}_r$</span> denotes the left unit law. The operations <span class="mathjax">$\circ_l$</span> and <span class="mathjax">$\circ_r$</span> are called <mark>whiskering</mark>.
        </p>
        <pre><code class="hljs coq">Definition whiskerL {A : Type} {x y z : A} (p : x = y)
  {q r : y = z} (h : q = r) : p @ q = p @ r
:= 1 @@ h.

Definition whiskerR {A : Type} {x y z : A} {p q : x = y}
  (h : p = q) (r : y = z) : p @ r = q @ r
:= h @@ 1.</code></pre>
        <p>
          Next, since <span class="mathjax">$\alpha \circ_r r$</span> and <span class="mathjax">$q \circ_l \beta$</span> are composable 2-paths, we can define horizontal composition by:
        </p>
        <div class="mathjax">
          $$
          \alpha \star \beta :\equiv (\alpha \circ_r r)(q \circ_l \beta)
          $$
        </div>
        <p>
          Now, suppose that <span class="mathjax">$a \equiv b \equiv c$</span> so that all paths <span class="mathjax">$p, q, r, s$</span> are elements of <span class="mathjax">$\Omega(A, a)$</span>, and assume moreover that <span class="mathjax">$p \equiv q \equiv r \equiv s \equiv \texttt{refl}_a$</span>, so that <span class="mathjax">$\alpha : \texttt{refl}_a = \texttt{refl}_a$</span> and <span class="mathjax">$\beta : \texttt{refl}_a = \texttt{refl}_a$</span> are composable in both orders. In this case, we have:
        </p>
        <div class="mathjax">
          $$
          \alpha \star \beta = \alpha \circ \beta = \alpha \star' \beta = \beta \circ \alpha
          $$
        </div>
        <p>
          The foregoing fact, known as the <mark>Eckmann-Hilton argument</mark> comes from classical homotopy theory and is used later to show that higher homotopy groups of a type are always abelian groups.
        </p>
        <pre><code class="hljs coq">Definition eckmann_hilton {A : Type} {x:A} (p q : 1 = 1 :&gt; (x = x)) : p @ q = q @ p :=
  (whiskerR_p1 p @@ whiskerL_1p q)^
  @ (concat_p1 _ @@ concat_p1 _)
  @ (concat_1p _ @@ concat_1p _)
  @ (concat_whisker _ _ _ _ p q)
  @ (concat_1p _ @@ concat_1p _)^
  @ (concat_p1 _ @@ concat_p1 _)^
  @ (whiskerL_1p q @@ whiskerR_p1 p).</code></pre>
        <p>
          A <mark>pointed type</mark> <span class="mathjax">$(A, a)$</span> is a type <span class="mathjax">$A : \mathscr{U}$</span> together with a point <span class="mathjax">$a : A$</span> called its <mark>basepoint</mark>. We write <span class="mathjax">$\mathscr{U}_\bullet :\equiv \Sigma_{A : \mathscr{U}}$</span> for the type of pointed types in universe <span class="mathjax">$\mathscr{U}$</span>.
        </p>
        <p>
          Given a pointed type <span class="mathjax">$(A, a)$</span>, we can define the <mark>loop space</mark> of <span class="mathjax">$(A, a)$</span> to be the following pointed type:
        </p>
        <div class="mathjax">
          $$
          \Omega(A, a) :\equiv ((a =_A a), \texttt{refl}_a)
          $$
        </div>
        <p>
          An element of it will be called a <mark>loop</mark> at a. For <span class="mathjax">$n : \mathbb{N}$</span>, the <mark>n-fold iterated loop space</mark> <span class="mathjax">$\Omega^n(A, a)$</span> of a pointed type <span class="mathjax">$(A, a)$</span> is defined recursively by:
        </p>
        <div class="mathjax">
          $$
          \Omega^0(A, a) :\equiv (A, a) \\
            \Omega^{n + 1}(A, a) :\equiv \Omega^n(\Omega(A, a))
          $$
        </div>
        <p>
          An element of it will be called an <mark>n-loop</mark> at <span class="mathjax">$a$</span>.
        </p>
        <h2 id="functions-are-functors">
          Functions are functors
        </h2>
        <p>
          From a type theoretic perspective, functions should respect equality; topologically, this corresponds to saying that every function is continuous (or preserves paths).
        </p>
        <p class="exercise">
          Given function <span class="mathjax">$f : A \rightarrow B$</span>, then for <span class="mathjax">$x, y : A$</span>, there is an operation
        </p>
        <div class="mathjax">
          $$
          \texttt{ap}_f : (x =_A y) \rightarrow (f(x) =_B f(y))
          $$
        </div>
        <p>
          <span class="mathjax">$\texttt{ap}_f$</span> can be read as the application of a function to a path.
        </p>
        <pre><code class="hljs coq">Definition ap {A B : Type} (f : A -&gt; B) {x y : A} (p : x = y) : f x = f y
  := match p with idpath =&gt; idpath end.</code></pre>
        <p>
          To provide a simple proof, it suffices to assume that <span class="mathjax">$p$</span> is <span class="mathjax">$\texttt{refl}_x$</span>. In this case, we may define <span class="mathjax">$\texttt{ap}_f(p) :\equiv \texttt{refl}_{f(x)} f(x) = f(x)$</span>. We will often write <span class="mathjax">$\texttt{ap}_f(p)$</span> as <span class="mathjax">$f(p)$</span>, and this matches the common category theory convention of using the same symbol for application of a functor to objects and morphisms.
        </p>
        <p class="exercise">
          We will now provide some facts about <span class="mathjax">$\texttt{ap}_f$</span> without proof.
        </p>
        <ol class="olitems" type="i" start="1">
          <li>
            <span class="mathjax">$\texttt{ap}_f(p \circ q) = \texttt{ap}_f(p) \circ \texttt{ap}_f(q)$</span>
          </li>
          <li>
            <span class="mathjax">$\texttt{ap}_f(p^{-1}) = \texttt{ap}_f(p)^{-1}$</span>
          </li>
          <li>
            <span class="mathjax">$\texttt{ap}_g(\texttt{ap}_f(p)) = \texttt{ap}_{g \circ f}(p)$</span>
          </li>
          <li>
            <span class="mathjax">$\texttt{ap}_{\texttt{id}_A} = p$</span>
          </li>
        </ol>
        <p>
          These are themselves paths, which have to satisfy coherence laws, as usual.
        </p>
        <h2 id="type-families-are-fibrations">
          Type families are fibrations
        </h2>
        <p>
          If <span class="mathjax">$\Pi_{x : A} B(x)$</span> and <span class="mathjax">$p : x = y$</span>, then <span class="mathjax">$f(x) : B(x)$</span> and <span class="mathjax">$f(y) : B(y)$</span> are elements of distinct types, so that a priori, we cannot even ask whether they are equal. The misssing ingredient is that <span class="mathjax">$p$</span> itself gives us a way to relate <span class="mathjax">$B(x)$</span> and <span class="mathjax">$B(y)$</span>. This problem was stated as <mark>indiscrenability of identicals</mark> in our <a href="/HoTT/1#identity-types">previous note</a>.
        </p>
        <p class="exercise">
          <mark>Transport lemma</mark>. Suppose <span class="mathjax">$P$</span> is a type family over <span class="mathjax">$A$</span> and <span class="mathjax">$p : x =_A y$</span>, then there is a function <span class="mathjax">$p_\star : P(x) \rightarrow P(y)$</span>.
        </p>
        <p>
          Let <span class="mathjax">$D : \Pi_{x, y : A}(x = y) \rightarrow \mathscr{U}$</span> be the type family defined by:
        </p>
        <div class="mathjax">
          $$
          D(x, y, p) :\equiv P(x) \rightarrow P(y)
          $$
        </div>
        <p>
          then we have the function
        </p>
        <div class="mathjax">
          $$
          d :\equiv \lambda x . \texttt{id}_{P(x)} : \Pi_{x : A} D(x, x, \texttt{refl}_x)
          $$
        </div>
        <p>
          so that the induction principle gives us <span class="mathjax">$\texttt{ind}_{=A}(D, d, x, y, p) : P(x) \rightarrow P(y)$</span>.
        </p>
        <p>
          Sometimes, it is necessary to notate the type family <span class="mathjax">$P$</span> in which the transport operation happens:
        </p>
        <div class="mathjax">
          $$
          \texttt{transport}^P(p, -) : P(x) \rightarrow P(y)
          $$
        </div>
        <p>
          Topologically, the transport lemma can be viewed as a "path lifting" operation on a fibration. We think of a type famiy <span class="mathjax">$P : A \rightarrow \mathscr{U}$</span> as a fibration with base space <span class="mathjax">$A$</span>, with <span class="mathjax">$P(x)$</span> being the fiber over <span class="mathjax">$x$</span>, and with <span class="mathjax">$\Sigma_{x : A} P(x)$</span> being the <mark>total space</mark> of the fibration, with first projection <span class="mathjax">$\Sigma_{x : A} P(x) \rightarrow A$</span>.
        </p>
        <p>
          The defining property of a fibration is that given a path <span class="mathjax">$p : x = y$</span> in the base space <span class="mathjax">$A$</span> and a point <span class="mathjax">$u : P(x)$</span> in a fiber over <span class="mathjax">$x$</span>, we may lift we may lift the path <span class="mathjax">$p$</span> to a total space starting at <span class="mathjax">$u$</span>, and this lifting can be done continuously. The point <span class="mathjax">$p_\star(u)$</span> can be thought of as the other endpoint of this lifted path.
        </p>
        <pre><code class="hljs coq">Definition transport {A : Type} (P : A -&gt; Type) {x y : A} (p : x = y) (u : P x) : P y :=
  match p with idpath =&gt; u end.</code></pre>
        <p class="exercise">
          We now state <mark>path lifting property</mark> without proof. Let <span class="mathjax">$P : A \rightarrow \mathscr{U}$</span> be a type family over <span class="mathjax">$A$</span>, and assume we have <span class="mathjax">$u : P(x)$</span> for some <span class="mathjax">$x : A$</span>. Then, for <span class="mathjax">$p : x = y$</span>, we have:
        </p>
        <div class="mathjax">
          $$
          \texttt{lift}(u, p) : (x, y) = (y, p_\star(u))
          $$
        </div>
        <p>
          in <span class="mathjax">$\Sigma_{x : A} P(x)$</span>, such that <span class="mathjax">$\texttt{pr}_1(\texttt{lift}(u, p)) = p$</span>.
        </p>
        <pre><code class="hljs coq">Definition equiv_path_sigma `(P : A -&gt; Type) (u v : sigT P)
: {p : u.1 = v.1 &amp;  p # u.2 = v.2} &lt;~&gt; (u = v)
  := Build_Equiv _ _ (path_sigma_uncurried P u v) _.</code></pre>
        <p>
          In classical homotopy theory, a fibration is defined as a map for which there exist liftings of paths, while in contrast, we have shown that in type theory, every type family comes with a specified "lifting function".
        </p>
        <p>
          When the type family <span class="mathjax">$P : A \rightarrow \mathscr{U}$</span> is regarded as a fibration, the base is <span class="mathjax">$A$</span>, and the total space is <span class="mathjax">$\Sigma_{x : A} P(x)$</span>. We may also refer to the dependent function <span class="mathjax">$\Pi_{x : A} P(x)$</span> as the <mark>section</mark> of the fibration <span class="mathjax">$P$</span>, and we may say that something happens <mark>fiberwise</mark> if it happens for each <span class="mathjax">$P(x)$</span>. For instance, a section <span class="mathjax">$f : \Pi_{x : A} P(x)$</span> shows that <span class="mathjax">$P$</span> is "fiberwise inhabited".
        </p>
        <p>
          We can now prove a dependent version of the lemma <span class="mathjax">$\texttt{ap}_f : (x =_A y) \rightarrow (f(x) =_B f(b))$</span> as follows. Given <span class="mathjax">$\Pi_{x : A} P(x)$</span>, we can define a non-dependent version of the function <span class="mathjax">$f' : A \rightarrow \Sigma_{x : A} P(x)$</span> by setting <span class="mathjax">$f'(x) :\equiv (x, f(x))$</span> and consider <span class="mathjax">$f'(p) : f'(x) = f'(y)$</span>. Since <span class="mathjax">$\texttt{pr}_1 \circ f' \equiv \texttt{id}_A$</span>, we have <span class="mathjax">$\texttt{pr}_1(f'(p)) \equiv p$</span>; thus <span class="mathjax">$f'(p)$</span> does "lie over" <span class="mathjax">$p$</span> in this sense. However, it is not obvious from the type of <span class="mathjax">$f'(p)$</span> that it lies over any specific path in <span class="mathjax">$A$</span> (in this case <span class="mathjax">$p$</span>), which is sometimes important.
        </p>
        <p>
          The solution is to use the transport lemma; we have a canonical path <span class="mathjax">$\texttt{lift}(u, p)$</span> from <span class="mathjax">$(x, u)$</span> to <span class="mathjax">$(u, p_\star(u))$</span>, which lies over <span class="mathjax">$p$</span>. Thus, any path from <span class="mathjax">$u : P(x)$</span> to <span class="mathjax">$v : P(y)$</span> lying over <span class="mathjax">$p$</span> should factor through <span class="mathjax">$\texttt{lift}(u, p)$</span>.
        </p>
        <p class="exercise">
          <mark>Dependent map</mark>. Suppose <span class="mathjax">$f : \Pi_{x : A} P(x)$</span>, we have a map
        </p>
        <div class="mathjax">
          $$
          \texttt{apd}_f : \Pi_{p : x = y} p_\star(f(x)) =_{P(y)} f(y)
          $$
        </div>
        <pre><code class="hljs coq">(** Similarly, dependent functions act on paths; but the type is a bit more subtle.
If [f : forall a:A, B a] and [p : x = y] is a path in [A], then [apD f p] should somehow
be a path between [f x : B x] and [f y : B y]. Since these live in different types,
we use transport along [p] to make them comparable: [apD f p : p # f x = f y].

  The type [p # f x = f y] can profitably be considered as a heterogeneous or
  dependent equality type, of "paths from [f x] to [f y] over [p]". *)

Definition apD {A : Type} {B : A-&gt;Type} (f : forall a: A, B a) {x y : A} (p : x=y):
  p # (f x) = f y
  :=
  match p with idpath =&gt; idpath end.</code></pre>
        <p>
          We prove it as follows. Let <span class="mathjax">$D : \Pi_{x, y : A} (x = y) \rightarrow \mathscr{U}$</span> be the type family defined by
        </p>
        <div class="mathjax">
          $$
          D(x, y, p) :\equiv p_\star(f(x)) = f(y)
          $$
        </div>
        <p>
          Then <span class="mathjax">$D(x, x, \texttt{refl}_x)$</span> is (<span class="mathjax">$\texttt{refl}_x)_\star = f(x)$</span>. Then we get <span class="mathjax">$D(x, x, \texttt{refl}_x) \equiv f(x) = f(x)$</span>. Thus, we find the function:
        </p>
        <div class="mathjax">
          $$
          d :\equiv \lambda x . \texttt{refl}_{f(x)} : \Pi_{x : A} D(x, x, \texttt{refl}_x)
          $$
        </div>
        <p>
          and now, path induction gives us <span class="mathjax">$\texttt{apd}_f(p) : p_\star(f(x)) = f(y)$</span> for each <span class="mathjax">$p : x = y$</span>.
        </p>
        <p>
          We will refer generally to paths which "lie over paths" in this sense as <mark>dependent paths</mark>. Since a non-dependently typed function is a special case of a dependently typed function, we have the following relation between <span class="mathjax">$\texttt{apd}_f$</span> and <span class="mathjax">$\texttt{ap}_f$</span>:
        </p>
        <p class="exercise">
          If <span class="mathjax">$P : A \rightarrow \mathscr{U}$</span> is defined by <span class="mathjax">$P(x) :\equiv B$</span> for a fixed <span class="mathjax">$B : \mathscr{U}$</span>, then for any <span class="mathjax">$x, y : A$</span>, <span class="mathjax">$p : x = y$</span>, and <span class="mathjax">$b : B$</span>, we have a path:
        </p>
        <div class="mathjax">
          $$
          \texttt{transportconst}^B_P(b) : \texttt{transport}^P(p, b) = b
          $$
        </div>
        <p>
          The corresponding Coq code looks like:
        </p>
        <pre><code class="hljs coq">(** Transporting in a constant fibration. *)
Definition transport_const {A B : Type} {x1 x2 : A} (p : x1 = x2) (y : B)
  : transport (fun x =&gt; B) p y = y.
Proof.
  destruct p. exact 1.
Defined.</code></pre>
        <p>
          In English, it suffices to assume that <span class="mathjax">$y$</span> is <span class="mathjax">$x$</span>, and <span class="mathjax">$p$</span> is <span class="mathjax">$\texttt{refl}_x$</span>. But <span class="mathjax">$\texttt{transport}^P(\texttt{refl}_x, b) \equiv b$</span>, so in this case, we have to prove that <span class="mathjax">$b = b$</span>, which can be discharged by <span class="mathjax">$\texttt{refl}_b$</span>.
        </p>
        <p>
          By concatenating <span class="mathjax">$\texttt{transportconst}$</span> and its inverse, we obtain:
        </p>
        <div class="mathjax">
          $$
          f(x) = f(y) \rightarrow p_\star(f(x) = f(y)) \\
            p_\star(f(x) = f(y)) \rightarrow f(x) = f(y)
          $$
        </div>
        <p class="exercise">
          Let us now dump a few definitions and lemmas in Coq:
        </p>
        <pre><code class="hljs coq">(** In a constant fibration, [apD] reduces to [ap], modulo [transport_const]. *)
Lemma apD_const {A B} {x y : A} (f : A -&gt; B) (p : x = y) :
  apD f p = transport_const p (f x) @ ap f p.
Proof.
  destruct p; reflexivity.
Defined.</code></pre>
        <pre><code class="hljs coq">(** Transporting in a pulled back fibration. *)
Lemma transport_compose {A B} {x y : A} (P : B -&gt; Type) (f : A -&gt; B)
  (p : x = y) (z : P (f x))
  : transport (fun x =&gt; P (f x)) p z  =  transport P (ap f p) z.
Proof.
  destruct p; reflexivity.
Defined.</code></pre>
        <pre><code class="hljs coq">Lemma ap_transport {A} {P Q : A -&gt; Type} {x y : A} (p : x = y) (f : forall x, P x -&gt; Q x) (z : P x) :
  f y (p # z) = (p # (f x z)).
Proof.
  by induction p.
Defined.</code></pre>
        <pre><code class="hljs coq">Definition transport_pp {A : Type} (P : A -&gt; Type) {x y z : A} (p : x = y) (q : y = z) (u : P x) :
  p @ q # u = q # p # u :=
  match q with idpath =&gt;
    match p with idpath =&gt; 1 end
  end.</code></pre>
        <h2 id="homotopies-and-equivalences">
          Homotopies and equivalences
        </h2>
        <p>
          It is now time to talk about identifications between types and functions. For two functions to be equal, they must agree on every element in their domains. Let <span class="mathjax">$f, g : \Pi_{x : A} P(x)$</span> be two sections of of the type family <span class="mathjax">$P : A \rightarrow \mathscr{U}$</span>. A homotopy from <span class="mathjax">$f$</span> to <span class="mathjax">$g$</span> is the dependent function:
        </p>
        <div class="mathjax">
          $$
          f \sim g :\equiv \Pi_{x : A} f(x) = g(x)
          $$
        </div>
        <p>
          Note that this is not the same thing as <span class="mathjax">$f = g$</span>, but we will revisit this when we talk about the univalence axiom.
        </p>
        <p>
          Just as functions in type theory are automatically functors, homotopies are automatically natural transforms:
        </p>
        <div class="mathjax">
          $$
          \Pi_{f : \Pi_{x : A} P(x)} (f \sim f) \\
            \Pi_{f, g : \Pi_{x : A} P(x)} (f \sim g) \rightarrow (g \sim f) \\
            \Pi_{f, g, h : \Pi_{x : A} P(x)} (f \sim g) \rightarrow (g \sim h) \rightarrow (f \sim h)
          $$
        </div>
        <p class="exercise">
          Suppose <span class="mathjax">$H : f \sim g$</span> is a homotopy between functions <span class="mathjax">$f, g : A \rightarrow B$</span> and let <span class="mathjax">$p : x =_A y$</span>. Then we have:
        </p>
        <div class="mathjax">
          $$
          H(x) \circ g(p) = f(p) \circ H(y)
          $$
        </div>
        <p>
          We may also draw the commutative diagram:
        </p>
        <div class="mathjax">
          $$
            \begin{xy}
            \xymatrix{
          
          f(x)\ar@{=}[r]^{f(p)}\ar@{=}[d]_{H(x)} & f(y)\ar@{=}[d]^{H(y)} \\
            g(x)\ar@{=}[r]_{g(p)} & g(y)
            }
            \end{xy}
          
          $$
        </div>
        <p>
          To supply a proof by induction, we may assume that <span class="mathjax">$p$</span> is <span class="mathjax">$\texttt{refl}_x$</span>. Since <span class="mathjax">$\texttt{ap}_f$</span> and <span class="mathjax">$\texttt{ap}_g$</span> compute on reflexivity, in this case, what we must show is:
        </p>
        <div class="mathjax">
          $$
          H(x) \circ \texttt{refl}_{g(x)} = \texttt{refl}_{f(x)} \circ H(x)
          $$
        </div>
        <p>
          But this follows since both sides are equal to <span class="mathjax">$H(x)$</span>.
        </p>
        <pre><code class="hljs coq">(** Naturality of [ap]. *)
Definition concat_Ap {A B : Type} {f g : A -&gt; B} (p : forall x, f x = g x) {x y : A} (q : x = y) :
  (ap f q) @ (p y) = (p x) @ (ap g q)
  :=
  match q with
    | idpath =&gt; concat_1p _ @ ((concat_p1 _) ^)
  end.</code></pre>
        <p class="exercise">
          Let <span class="mathjax">$H : f \sim \texttt{id}_A$</span> be a homotopy with <span class="mathjax">$f : A \rightarrow A$</span>. Then for any <span class="mathjax">$x : A$</span>, we have:
        </p>
        <div class="mathjax">
          $$
            \begin{xy}
            \xymatrix{
          
          f f x\ar@{=}[r]^{f(H x)}\ar@{=}[d]_{H(f x)} & f x\ar@{=}[d]^{H x} \\
            f x\ar@{=}[r]_{Hx} & x
            }
            \end{xy}
          
          $$
        </div>
        <p>
          That is, <span class="mathjax">$f(H x) \circ H x = H(f x) \circ H x$</span>. We can now whisker by <span class="mathjax">$(H x)^{-1}$</span> to cancel <span class="mathjax">$H x$</span> obtaining:
        </p>
        <div class="mathjax">
          $$
          f(H x) = f(H x) \circ H x \circ (H x)^{-1} = H(f x) \circ H x \circ (H x)^{-1} = H(f x) \circ H x \circ (H x)^{-1} = H(f x)
          $$
        </div>
        <pre><code class="hljs coq">(** Naturality of [ap] at identity. *)
Definition concat_A1p {A : Type} {f : A -&gt; A} (p : forall x, f x = x) {x y : A} (q : x = y) :
  (ap f q) @ (p y) = (p x) @ q
  :=
  match q with
    | idpath =&gt; concat_1p _ @ ((concat_p1 _) ^)
  end.</code></pre>
        <p>
          Moving onto types from a traditional perspective, one may say that a function <span class="mathjax">$f : A \rightarrow B$</span> is an <mark>isomorphism</mark> if there is a function <span class="mathjax">$g : B \rightarrow A$</span> such that composites <span class="mathjax">$f \circ g \sim \texttt{id}_B$</span> and <span class="mathjax">$g \circ f \sim \texttt{id}_A$</span>. A homotopical perspective suggests that this should be called a homotopy equivalence, and equivalence of higher groupoids from a category theoretic perspective. However, the type
        </p>
        <div class="mathjax">
          $$
          \Sigma_{g : B \rightarrow A} (f \circ g \sim \texttt{id}_B) \times (g \circ f \sim \texttt{id}_A)
          $$
        </div>
        <p>
          is poorly behaved. For instance, a single function <span class="mathjax">$f : A \rightarrow B$</span>, there may be multiple unequal multiple inhabitants. This is closely related to the observation in higher category theory that one often needs to consider <mark>adjoint equivalences</mark>. Let us instead do the following:
        </p>
        <p>
          Given <span class="mathjax">$f : A \rightarrow B$</span>, a quasi-inverse of <span class="mathjax">$f$</span> is a triple <span class="mathjax">$(g, \alpha, \beta)$</span> consisting of a function <span class="mathjax">$g : B \rightarrow A$</span> and homotopies <span class="mathjax">$\alpha : f \circ g \sim \texttt{id}_B$</span> and <span class="mathjax">$\beta : g \circ f \sim \texttt{id}_A$</span>. The quasi-inverse of <span class="mathjax">$f$</span> is denoted <span class="mathjax">$\texttt{qinv}(f)$</span>.
        </p>
        <p>
          In general, we will reserve the use of the term isomorphism in the special case when <span class="mathjax">$A$</span> and <span class="mathjax">$B$</span> behave like sets, where it is unproblematic. Let us define <mark>equivalence</mark> for an improved notation <span class="mathjax">$isequiv(f)$</span> with the following properties:
        </p>
        <ol class="olitems" type="i" start="1">
          <li>
            For each <span class="mathjax">$f: A \rightarrow B$</span>, there is a function <span class="mathjax">$\texttt{qinv}(f) \rightarrow \texttt{isequiv}(f)$</span>
          </li>
          <li>
            Similarly, for each <span class="mathjax">$f$</span>, we have <span class="mathjax">$\texttt{isequiv}(f) \rightarrow \texttt{qinv}$</span>
          </li>
          <li>
            For any two inhabitants <span class="mathjax">$e_1, e_2 : \texttt{isequiv}(f)$</span>, we have <span class="mathjax">$e_1 = e_2$</span>
          </li>
        </ol>
        <p>
          Later, we will see many different definitions of <span class="mathjax">$\texttt{isequiv}(f)$</span>, all of which satisfy these properties. For now, let us be satiated with the easiest such definition:
        </p>
        <div class="mathjax">
          $$
          \texttt{isequiv}(f) :\equiv (\Sigma_{g : B \rightarrow A} f \circ g \sim \texttt{id}_B) \times (\Sigma_{h : B \rightarrow A} h \circ f \sim \texttt{id}_A)
          $$
        </div>
        <p>
          For the moment, the main takeaway is that we have a well-defined meaning for "<span class="mathjax">$f$</span> is an equivalence" by exhibiting a quasi-inverse to it. We can write
        </p>
        <div class="mathjax">
          $$
          A \simeq B :\equiv \Sigma_{f : A \rightarrow B} \texttt{isequiv(f)}
          $$
        </div>
        <p class="exercise">
          Type equivalence is an equivalence relation on <span class="mathjax">$\mathscr{U}$</span>. More specifically,
        </p>
        <ol class="olitems" type="i" start="1">
          <li>
            For any <span class="mathjax">$A$</span>, the identity fuction <span class="mathjax">$\texttt{id}_A$</span> is an equivalence; <span class="mathjax">$A \simeq A$</span>
          </li>
          <li>
            For any <span class="mathjax">$f : A \simeq B$</span>, we have an equivalence <span class="mathjax">$f^{-1} : B \simeq A$</span>
          </li>
          <li>
            For any <span class="mathjax">$f : A \simeq B$</span>, <span class="mathjax">$g : B \simeq C$</span>, we have <span class="mathjax">$g \circ f : A \simeq C$</span>
          </li>
        </ol>
        <h2 id="the-higher-groupoid-structure-of-type-formers">
          The higher groupoid structure of type formers
        </h2>
        <p>
          The goal now is to form new types corresponding to the type theoretic ones from our <a href="/HoTT/1">previous note</a>. For instance, a cartesian product <span class="mathjax">$A = B \times C$</span>, <span class="mathjax">$x :\equiv (b, c)$</span>, <span class="mathjax">$y :\equiv (b', c')$</span>, then we have:
        </p>
        <div class="mathjax">
          $$
          (b, c) = (b', c') \simeq (b = b') \times (c = c')
          $$
        </div>
        <p>
          In more traditional language, two ordered pairs are equal just when their components are equal. The higher structure of identity types can also be expressed in terms of those equivalences. Similarly, when a type family <span class="mathjax">$P : A \rightarrow \mathscr{U}$</span> is built up fiberwise, up to homotopy, in terms of the corresponding operations on the data that went into <span class="mathjax">$P$</span>. For instance, <span class="mathjax">$P(x) = B(x) \times C(x)$</span>. Then, we have:
        </p>
        <div class="mathjax">
          $$
          \texttt{transport}^P(p, (b, c)) = (\texttt{transport}^B(p, b), \texttt{transport}^C(p, c)
          $$
        </div>
        <p>
          Finally, the type forming rules are also functorial, and if a function <span class="mathjax">$f$</span> is built from this functorially, then the operations <span class="mathjax">$\texttt{ap}_f$</span> and <span class="mathjax">$\texttt{apd}_f$</span> can be computed based on the corresponding ones on the data going into into <span class="mathjax">$f$</span>. For instance, <span class="mathjax">$g : B \rightarrow B'$</span> and <span class="mathjax">$h : C \rightarrow C'$</span>, and we define <span class="mathjax">$f : B \times C \rightarrow B' \times C'$</span> by <span class="mathjax">$f(b,c) :\equiv (g(b), h(c))$</span>, then modulo equivalence, we can identify <span class="mathjax">$\texttt{ap}_f$</span> with <span class="mathjax">$(\texttt{ap}_g, \texttt{ap}_h)$</span>.
        </p>
        <p>
          Since our philosophy states that identity types are defined uniformly for all types by their induction principle, so we cannot redefine them to be different for different types. The <a href="/HoTT/1">previous note</a> is insufficient to prove the desired theorems for two type formers: <span class="mathjax">$\Pi$</span> types and universes. For <span class="mathjax">$\Pi$</span> types, we use the axiom of <mark>functional extensionality</mark>, and for universes, we use the <mark>univalence axiom</mark>, which we will state shortly.
        </p>
        <p>
          It is, however, important to note that not all identity types can be determined by induction over the construction of types. Counterexamples include most non-trivial <mark>higher inductive types</mark> (HITs). For instance, calculating the identity types of types <span class="mathjax">$\mathbb{S}^n$</span> is equivalent to calculating the higher homotopy groups of spheres, a field of research in algebraic topology.
        </p>
        <h2 id="cartesian-product-types">
          Cartesian product types
        </h2>
        <p>
          We have the following function which we will prove is an equivalence by exhibiting its quasi-inverse:
        </p>
        <div class="mathjax">
          $$
          (x =_{A \times B} y) \rightarrow (\texttt{pr}_1(x) =_A \texttt{pr}_1(y)) \times (\texttt{pr}_2(x) =_B \texttt{pr}_2(y))
          $$
        </div>
        <pre><code class="hljs coq">Definition equiv_path_prod {A B : Type} (z z' : A * B)
  : (fst z = fst z') * (snd z = snd z')  &lt;~&gt;  (z = z')
  := Build_Equiv _ _ (path_prod_uncurried z z') _.</code></pre>
        <p>
          We can now denote this by
        </p>
        <div class="mathjax">
          $$
          \texttt{pair}^= : (\texttt{pr}_1(x) = \texttt{pr}_1(y)) \times (\texttt{pr}_2(x) = \texttt{pr}_2(y)) \rightarrow x = y
          $$
        </div>
        <p>
          It can be helpful view <span class="mathjax">$\texttt{pair}^=$</span> as an <mark>introduction rule</mark> for <span class="mathjax">$x = y$</span>.  to The elimination rules can then be written out as:
        </p>
        <div class="mathjax">
          $$
          \texttt{ap}_{pr_1} : (x = y) \rightarrow (\texttt{pr}_1(x) = \texttt{pr}_1(y)) \\
            \texttt{ap}_{pr_2} : (x = y) \rightarrow (\texttt{pr}_2(x) = \texttt{pr}_2(y))
          $$
        </div>
        <p>
          For <span class="mathjax">$p : \texttt{pr}_1 x = \texttt{pr}_1 y$</span> and <span class="mathjax">$q : \texttt{pr}_2 x = \texttt{pr}_2 y$</span>, we get the following <mark>propositional uniqueness principle</mark>:
        </p>
        <div class="mathjax">
          $$
          r = \texttt{pair}^=(\texttt{ap}_{pr_1}(r), \texttt{ap}_{pr_2}(r)) \quad r : x =_{A \times B} y
          $$
        </div>
        <pre><code class="hljs coq">Definition transport_prod {A : Type} {P Q : A -&gt; Type} {a a' : A} (p : a = a')
  (z : P a * Q a)
  : transport (fun a =&gt; P a * Q a) p z  =  (p # (fst z), p # (snd z))
  := match p with idpath =&gt; 1 end.</code></pre>
        <pre><code class="hljs coq">Definition ap_functor_prod {A A' B B' : Type} (f : A -&gt; A') (g : B -&gt; B')
  (z z' : A * B) (p : fst z = fst z') (q : snd z = snd z')
  : ap (functor_prod f g) (path_prod _ _ p q)
  = path_prod (functor_prod f g z) (functor_prod f g z') (ap f p) (ap g q).
Proof.
  destruct z as [a b]; destruct z' as [a' b'].
  simpl in p, q. destruct p, q. reflexivity.
Defined.</code></pre>
        <h2 id="sigma-types">
          $\Sigma$-types
        </h2>
        <p>
          Suppose we have a path <span class="mathjax">$p : w = w'$</span> in <span class="mathjax">$\Sigma_{x : A} P(x)$</span>. Then, we get <span class="mathjax">$\texttt{pr}_1(p) : \texttt{pr}_1(w) = \texttt{pr}_1(w')$</span>. However, we cannot ask if <span class="mathjax">$\texttt{pr}_1(w)$</span> is identical to <span class="mathjax">$\texttt{pr}_1(w')$</span>, since they don't have the same type, but we can transport <span class="mathjax">$\texttt{pr}_2(w)$</span> along the path <span class="mathjax">$\texttt{pr}_1(p)$</span>, and this gives us an element of the same type as <span class="mathjax">$\texttt{pr}_2(w')$</span>. By path induction, we obtain the path <span class="mathjax">$\texttt{pr}_1(p)_\star(\texttt{pr}_2(w) = \texttt{pr}_2(w'))$</span>, which we can regard as the type of paths from <span class="mathjax">$\texttt{pr}_2(w)$</span> to <span class="mathjax">$\texttt{pr}_2(w')$</span>.
        </p>
        <div class="mathjax">
          $$
          (w = w') \simeq \Sigma_{p : \texttt{pr}_1(w) = \texttt{pr}_1(w')} p_\star(\texttt{pr}_2(w) = \texttt{pr}_2(w'))
          $$
        </div>
        <p>
          We have already proved this <a href="#type-families-are-fibrations">previously</a>, in the path lifting property. As usual, let us also deduce a propositional uniqueness principle as a special case:
        </p>
        <p class="exercise">
          For <span class="mathjax">$z : \Sigma_{x : A} P(x)$</span>, we have <span class="mathjax">$z = (\texttt{pr}_1(z), \texttt{pr}_2(z))$</span>
        </p>
        <pre><code class="hljs coq">Definition eta_sigma `{P : A -&gt; Type} (u : sigT P)
  : (u.1; u.2) = u
  := 1.</code></pre>
        <p class="exercise">
          Suppose we have the type families <span class="mathjax">$P : A \rightarrow \mathscr{U}$</span> and <span class="mathjax">$Q : (\Sigma_{x : A} P(x)) \rightarrow \mathscr{U}$</span>, then we can construct the type family over <span class="mathjax">$A$</span> defined by:
        </p>
        <div class="mathjax">
          $$
          x \mapsto \Sigma_{u : P(x)} Q(x, u)
          $$
        </div>
        <p>
          For any path <span class="mathjax">$p : x = y$</span>, we have <span class="mathjax">$(u, z) : \Sigma_{u : P(x)} Q(x, u)$</span>, we have
        </p>
        <div class="mathjax">
          $$
          p_\star(u, z) = (p_\star(u), \texttt{pair}^=(p, \texttt{refl}_{p_\star(u)})(z))
          $$
        </div>
        <pre><code class="hljs coq">(** Dependent transport is the same as transport along a [path_sigma]. *)
Definition transportD_is_transport
           {A : Type} (B : A-&gt;Type) (C: sigT B -&gt; Type)
           (x1 x2 : A) (p : x1 = x2) (y : B x1) (z : C (x1 ; y))
: transportD B (fun a b =&gt; C (a ; b)) p y z
  = transport C (path_sigma' B p 1) z.
Proof.
  destruct p. reflexivity.
Defined.</code></pre>
        <h2 id="the-unit-type">
          The unit type
        </h2>
        <p>
          Let us briefly discuss the type <span class="mathjax">$\mathbb{1}$</span>.
        </p>
        <p class="exercise">
          For <span class="mathjax">$x, y : \mathbb{1}$</span>, <span class="mathjax">$(x = y) \simeq \mathbb{1}$</span>.
        </p>
        <p>
          It's tempting to do this proof by <span class="mathjax">$\mathbb{1}$</span>-induction, but we'd get stuck and be unable to perform a path induction on <span class="mathjax">$p : \star = \star$</span>. A function <span class="mathjax">$(x = y) \rightarrow \mathbb{1}$</span> is easy to define by sending everything to <span class="mathjax">$\star$</span>. We may assume, by path induction, that <span class="mathjax">$x = y = \star$</span>, in which case, we have <span class="mathjax">$\texttt{refl}_\star : x = y$</span>, yielding a constant function <span class="mathjax">$\mathbb{1} \rightarrow (x = y)$</span>. To show the inverses, consider an element <span class="mathjax">$u : \mathbb{1}$</span>, and safely assume that <span class="mathjax">$u = \star$</span>, but this is also the result of the composite <span class="mathjax">$\mathbb{1} \rightarrow (x = y) \rightarrow \mathbb{1}$</span>.
        </p>
        <pre><code class="hljs coq">Definition equiv_path_unit (z z' : Unit) : Unit &lt;~&gt; (z = z')
  := Build_Equiv _ _ (path_unit_uncurried z z') _.</code></pre>
        <p class="exercise">
          <span class="mathjax">$\Pi$</span>-types and functional extensionality
        </p>
        <p>
          We expect type <span class="mathjax">$f = g$</span> of paths from <span class="mathjax">$f$</span> to <span class="mathjax">$g$</span> in <span class="mathjax">$\Pi_{x : A} B(x)$</span> to be equivalent to the type of pointwise paths:
        </p>
        <div class="mathjax">
          $$
          (f = g) \simeq \Pi_{x : A} (f(x) =_{B(x)} g(x))
          $$
        </div>
        <p>
          The <mark>functional extensionality</mark> axiom says that the above relation is an equivalence. This implies that there is a quasi-inverse:
        </p>
        <div class="mathjax">
          $$
          \texttt{funext} : (\Pi_{x : a} f(x) = g(x)) \rightarrow (f = g)
          $$
        </div>
        <p>
          We can regard this as an introduction rule for the type <span class="mathjax">$f = g$</span>.
        </p>
        <pre><code class="hljs coq">Definition path_forall `{Funext} {A : Type} {P : A -&gt; Type} (f g : forall x : A, P x) :
  f == g -&gt; f = g
  :=
  (@apD10 A P f g)^-1.</code></pre>
        <p>
          From this point of view, <span class="mathjax">$\texttt{happly}$</span> is an elimination rule, while the homotopies witnessing <span class="mathjax">$\texttt{funext}$</span> as quasi-inverse to <span class="mathjax">$\texttt{happly}$</span> become a propositional computation rule:
        </p>
        <div class="mathjax">
          $$
          \texttt{happly}(\texttt{funext}(h), x) = h(x) \quad h : \Pi_{x : A} (f(x) = g(x))
          $$
        </div>
        <p>
          and a propositional uniqueness principle,
        </p>
        <div class="mathjax">
          $$
          p = \texttt{funext}(x \mapsto \texttt{happly}(p, x)) \quad p : f = g
          $$
        </div>
        <p>
          We can also compute identity, inverses, and compositions in <span class="mathjax">$\Pi$</span>-types; they are simply given by pointwise operations:
        </p>
        <div class="mathjax">
          $$
          \texttt{refl}_f = \texttt{funext}(x \mapsto \texttt{refl}_{f(x)}) \\
            \alpha^{-1} = \texttt{funext}(x \mapsto \texttt{happly}(\alpha, x)^{-1}) \\
            \alpha \circ \beta = \texttt{funext}(x \mapsto \texttt{happly}(\alpha, x) \circ \texttt{happly}(\beta, x))
          $$
        </div>
        <p>
          For the non-dependent function <span class="mathjax">$A \rightarrow B$</span>, a special case of the corresponding dependent function, the rules for transport are quite straightforward:
        </p>
        <div class="mathjax">
          $$
          \texttt{transport}^{A \rightarrow B}(p, f) = (x \mapsto \texttt{transport}^B(p, f(\texttt{transport}^A(p^{-1}, x))))
          $$
        </div>
        <p class="exercise">
          Given type families <span class="mathjax">$A, B : X \rightarrow \mathscr{U}$</span>, <span class="mathjax">$p : x =_X y$</span>, <span class="mathjax">$f : A(x) \rightarrow B(x)$</span>, and <span class="mathjax">$g : A(y) \rightarrow B(y)$</span>, we have an equivalence:
        </p>
        <div class="mathjax">
          $$
          (p_\star(f) = g) \simeq \Pi_{x : A(x)} (p_\star(f(a)) = g(p_\star(a)))
          $$
        </div>
        <pre><code class="hljs coq">(** Usually, a dependent path over [p:x1=x2] in [P:A-&gt;Type] between [y1:P x1] and [y2:P x2]
is a path [transport P p y1 = y2] in [P x2].  However, when [P] is a function space,
these dependent paths have a more convenient description: rather than transporting
the argument of [y1] forwards and backwards, we transport only forwards but on both sides
of the equation, yielding a "naturality square". *)
Definition dpath_arrow
  {A:Type} (B C : A -&gt; Type) {x1 x2 : A} (p : x1=x2)
  (f : B x1 -&gt; C x1) (g : B x2 -&gt; C x2)
  : (forall (y1 : B x1), transport C p (f y1) = g (transport B p y1))
  &lt;~&gt;
  (transport (fun x =&gt; B x -&gt; C x) p f = g).
Proof.
  destruct p.
  apply equiv_path_arrow.
Defined.</code></pre>
        <p>
          Moreover, if <span class="mathjax">$q : p_\star(f) = g$</span> corresponds under this equivalence to <span class="mathjax">$\hat{q}$</span>, then for <span class="mathjax">$a : A(x)$</span>, the path
        </p>
        <div class="mathjax">
          $$
          \texttt{happly}(q, p_\star(a)) : p_\star(f)(p_\star(a)) = g(p_\star(a))
          $$
        </div>
        <p>
          is equal to the composite:
        </p>
        <div class="mathjax">
          $$
          \begin{align*}
              (p_\star(f))(p_\star(a)) &= p_\star(f(p^{-1}_\star(p_\star(a)) & (\texttt{by transport lemma}) \\
                                       &= p_\star(f(a)) & \\
                                       &= g(p_\star(a)) & (\texttt{by } \hat{q})&
            \end{align*}
          $$
        </div>
        <h2 id="universes-and-the-univalence-axiom">
          Universes and the univalence axiom
        </h2>
        <p class="exercise">
          For types <span class="mathjax">$A, B : \mathscr{U}$</span>, there is a certain function
        </p>
        <div class="mathjax">
          $$
          \texttt{idtoequiv} : (A =_\mathscr{U} B) \rightarrow (A \simeq B)
          $$
        </div>
        <p>
          defined as follows.
        </p>
        <pre><code class="hljs coq">Definition equiv_path (A B : Type) (p : A = B) : A &lt;~&gt; B
  := Build_Equiv _ _ (transport (fun X:Type =&gt; X) p) _.</code></pre>
        <p class="exercise">
          The <mark>univalence axiom</mark> can be stated as the <span class="mathjax">$\texttt{idtoequiv}$</span> being an equivalene.
        </p>
        <div class="mathjax">
          $$
          (A =_\mathscr{U} B) \simeq (A \simeq B)
          $$
        </div>
        <pre><code class="hljs coq">Definition equiv_equiv_path  (A B : Type) : (A = B) &lt;~&gt; (A &lt;~&gt; B)
  := (equiv_path_universe A B)^-1%equiv.</code></pre>
        <p>
          As previously done, it is fruitful to break up this equivalence into:
        </p>
        <ol class="olitems" type="i" start="1">
          <li>
            Introduction rule:
          </li>
        </ol>
        <div class="mathjax">
          $$
          \texttt{ua} : (A \simeq B) \rightarrow (A =_\mathscr{U} B)
          $$
        </div>
        <ol class="olitems" type="i" start="2">
          <li>
            Elimination rule:
          </li>
        </ol>
        <div class="mathjax">
          $$
          \texttt{idtoequiv} \equiv \texttt{transport}^{X \rightarrow X} : (A =_\mathscr{U} B) \rightarrow (A \simeq B)
          $$
        </div>
        <ol class="olitems" type="i" start="3">
          <li>
            Propositional computation rule:
          </li>
        </ol>
        <div class="mathjax">
          $$
          \texttt{transport}^{X \rightarrow X}(\texttt{ua}(f), x) = f(x)
          $$
        </div>
        <ol class="olitems" type="i" start="4">
          <li>
            Propositional equivalence principle, for any <span class="mathjax">$p : A = B$</span>
          </li>
        </ol>
        <div class="mathjax">
          $$
          p = \texttt{ua}(\texttt{transport}^{X \rightarrow X}(p))
          $$
        </div>
        <p>
          We can also identify reflexvivity, concatenation, and inverses of equalities:
        </p>
        <div class="mathjax">
          $$
          \texttt{refl}_A = \texttt{ua}(\texttt{id}_A) \\
            \texttt{ua}(f) \circ \texttt{ua}(g) = \texttt{ua}(g \circ f) \\
            \texttt{ua}(f)^{-1} = ua(f^{-1})
          $$
        </div>
        <p class="exercise">
          For any type family <span class="mathjax">$B : A \rightarrow \mathscr{U}$</span> and <span class="mathjax">$x, y : A$</span> with a path <span class="mathjax">$p : x = y$</span> and <span class="mathjax">$u : B(x)$</span>, we have:
        </p>
        <div class="mathjax">
          $$
          \begin{align*}
            \texttt{transport}^P(p, u) &= \texttt{transport}^{X \rightarrow X}(\texttt{ap}_B(p), u) \\
                                       &= \texttt{idtoequiv}(\texttt{ap}_B(p))(u)
            \end{align*}
          $$
        </div>
        <h2 id="identity-type">
          Identity type
        </h2>
        <p>
          Just as the type <span class="mathjax">$a =_A a'$</span> is characterized upto isomorphism, with a separate definition for each <span class="mathjax">$A$</span>, there is no simple characterizion of the type <span class="mathjax">$p =_{a =_A a'} q$</span> of paths between paths <span class="mathjax">$p, q : a =_A a'$</span>.
        </p>
        <p class="exercise">
          If <span class="mathjax">$f : A \rightarrow B$</span> is an equivalence, then for all <span class="mathjax">$a, a' : A$</span> so is:
        </p>
        <div class="mathjax">
          $$
          \texttt{ap}_f : (a =_A a') \rightarrow (f(a) =_B f(a'))
          $$
        </div>
        <p>
          To prove this, let <span class="mathjax">$f^{-1}$</span> be a quasi inverse of <span class="mathjax">$f$</span> with the homotopies:
        </p>
        <div class="mathjax">
          $$
          \alpha : \Pi_{b : B} f(f^{-1}(b)) = b \\
            \beta : \Pi_{a : A} f(f^{-1}(a)) = a
          $$
        </div>
        <p>
          The quasi-inverse of <span class="mathjax">$ap_f$</span> is essentially:
        </p>
        <div class="mathjax">
          $$
          \texttt{ap}_{f^{-1}} : (f(a) = f(a')) \rightarrow (f^{-1}(f(a)) = f^{-1}(f(a')))
          $$
        </div>
        <p>
          However, in order to obtain an element of <span class="mathjax">$a =_A a'$</span> from <span class="mathjax">$\texttt{ap}_{f^{-1}}(q)$</span> we must concatenate with <span class="mathjax">$\beta_\alpha^{-1}$</span> and <span class="mathjax">$\beta_{\alpha'}$</span> on either side. For <span class="mathjax">$p : a =_A a'$</span> and <span class="mathjax">$q : f(a) =_B f(a')$</span>, we have:
        </p>
        <div class="mathjax">
          $$
          \beta_\alpha^{-1} \circ \texttt{ap}_f(\texttt{ap}_f(p)) \circ \beta_{\alpha'} = p \\
            \texttt{ap}_f(\beta_\alpha^{-1} \circ \texttt{ap}_{f^-1}(a) \circ \beta_{\alpha'}) = q
          $$
        </div>
        <p>
          We can prove the latter by simply canceling inverse paths.
        </p>
        <p>
          Thus, for some type <span class="mathjax">$A$</span>, we have a full characterizion of <span class="mathjax">$a =_A a'$</span> and the type <span class="mathjax">$p =_{a_{=A}} q$</span> is determined as well. For example, paths <span class="mathjax">$p = q$</span> where <span class="mathjax">$p, q : f =_{\Pi_{x : A} B(x)} g$</span> are equivalent to homotopies:
        </p>
        <div class="mathjax">
          $$
          \Pi_{x : A} (\texttt{happly}(p)(x) =_{f(x) = g(x)} \texttt{happly}(q)(x)
          $$
        </div>
        <p>
          Next, we consider transport in families of paths; ie.e. transport in <span class="mathjax">$C : A \rightarrow \mathscr{U}$</span> where each <span class="mathjax">$C(x)$</span> is an identity type.
        </p>
        <p class="exercise">
          For any <span class="mathjax">$A$</span> and <span class="mathjax">$a : A$</span> with <span class="mathjax">$p : x_1 = x_2$</span>, we have
        </p>
        <div class="mathjax">
          $$
          \begin{matrix}
            \texttt{transport}^{x \mapsto (a = x)}(p, q) = q \circ p & q : a = x_1 \\
            \texttt{transport}^{x \mapsto (x = a)}(p, q) = p^{-1} \circ q & q : x_1 = a \\
            \texttt{transport}^{x \mapsto (x = x)}(p, q = p^{-1} \circ q \circ p & q : x_1 = x_1
            \end{matrix}
          $$
        </div>
        <p class="exercise">
          We now dump some lemmas for <span class="mathjax">$\texttt{transport}$</span>:
        </p>
        <pre><code class="hljs coq">Definition transport_paths_FlFr {A B : Type} {f g : A -&gt; B} {x1 x2 : A}
  (p : x1 = x2) (q : f x1 = g x1)
  : transport (fun x =&gt; f x = g x) p q = (ap f p)^ @ q @ (ap g p).
Proof.
  destruct p; simpl.
  exact ((concat_1p q)^ @ (concat_p1 (1 @ q))^).
Defined.</code></pre>
        <pre><code class="hljs coq">Definition transport_paths_FlFr_D {A : Type} {B : A -&gt; Type}
  {f g : forall a, B a} {x1 x2 : A} (p : x1 = x2) (q : f x1 = g x1)
: transport (fun x =&gt; f x = g x) p q
  = (apD f p)^ @ ap (transport B p) q @ (apD g p).
Proof.
  destruct p; simpl.
  exact ((ap_idmap _)^ @ (concat_1p _)^ @ (concat_p1 _)^).
Defined.</code></pre>
        <pre><code class="hljs coq">Definition transport_paths_lr {A : Type} {x1 x2 : A} (p : x1 = x2) (q : x1 = x1)
  : transport (fun x =&gt; x = x) p q = p^ @ q @ p.
Proof.
  destruct p; simpl.
  exact ((concat_1p q)^ @ (concat_p1 (1 @ q))^).
Defined.</code></pre>
        <h2 id="natural-numbers">
          Natural numbers
        </h2>
        <p>
          We will introduce an encode-decode method to define <span class="mathjax">$\mathbb{N}$</span>. The codes for identites are a type family:
        </p>
        <div class="mathjax">
          $$
          \texttt{code} : \mathbb{N} \rightarrow \mathbb{N} \rightarrow \mathscr{U}
          $$
        </div>
        <p>
          defined by double recursion over <span class="mathjax">$\mathbb{N}$</span> as follows:
        </p>
        <div class="mathjax">
          $$
          \texttt{code}(0, 0) :\equiv \mathbf{1} \\
            \texttt{code}(\texttt{succ}(m), 0) :\equiv \mathbf{0} \\
            \texttt{code}(0, \texttt{succ}(n)) :\equiv \mathbf{0} \\
            \texttt{code}(\texttt{succ}(m), \texttt{succ}(n)) :\equiv \texttt{code}(m, n)
          $$
        </div>
        <p>
          We also define, by recursion, a dependent function <span class="mathjax">$r : \Pi_{n : \mathbb{N}} \texttt{code}(n, n)$</span> with
        </p>
        <div class="mathjax">
          $$
          r(0) :\equiv \star \\
            r(\texttt{succ}(n)) :\equiv r(n)
          $$
        </div>
        <p class="exercise">
          For all <span class="mathjax">$m, n : \mathbb{N}$</span>, we have <span class="mathjax">$(m = n) \simeq \texttt{code}(m, n)$</span>
        </p>
        <pre><code class="hljs coq">Definition equiv_path_nat {n m} : (n =n m) &lt;~&gt; (n = m)
  := Build_Equiv _ _ (@path_nat n m) _.</code></pre>
        <h2 id="universal-properties">
          Universal properties
        </h2>
        <p>
          By combining the path computation rules described in the previous sections, we can show that various type forming operations satisfy the expected universal properties, interpreted in a homotopical way as equivalences.
        </p>
        <div class="mathjax">
          $$
          (X \rightarrow A \times B) \rightarrow (X \rightarrow A) \times (X \rightarrow B)
          $$
        </div>
        <p>
          defined by <span class="mathjax">$f \mapsto (\texttt{pr}_1 \circ f, \texttt{pr}_2 \circ f)$</span>. To prove that this is an equivalence, given <span class="mathjax">$f : X \rightarrow A \times B$</span>, the round-trip composite yields the function:
        </p>
        <div class="mathjax">
          $$
          \lambda x . (\texttt{pr}_1(f(x)), \texttt{pr}_2(f(x))) = f \quad \texttt{by functional extensionality}
          $$
        </div>
        <p>
          We also have a dependently typed version of this universal property:
        </p>
        <div class="mathjax">
          $$
          (\Pi_{x : X} A(x) \times B(x)) \rightarrow (\Pi_{x : X} A(x)) \times (\Pi_{x : X} B(x))
          $$
        </div>
        <p>
          defined as before.
        </p>
        <pre><code class="hljs coq">(* First, a positive version of the universal property *)
Definition equiv_prod_ind `(P : A * B -&gt; Type)
  : (forall (a : A) (b : B), P (a, b)) &lt;~&gt; (forall p : A * B, P p)
  := Build_Equiv _ _ (prod_ind P) _.</code></pre>
        <pre><code class="hljs coq">(* Now the negative universal property. *)
Definition prod_coind_uncurried `{A : X -&gt; Type} `{B : X -&gt; Type}
  : (forall x, A x) * (forall x, B x) -&gt; (forall x, A x * B x)
  := fun fg x =&gt; (fst fg x, snd fg x).</code></pre>
        <p>
          Since <span class="mathjax">$\Sigma$</span> types are a generalization of cartesian product types, we can straightaway jump to the dependently typed version; if we have a type <span class="mathjax">$X$</span> and type families <span class="mathjax">$A : A \rightarrow \mathscr{U}$</span> and <span class="mathjax">$P : \Pi_{x : A} A(x) \rightarrow \mathscr{U}$</span>, then we have:
        </p>
        <div class="mathjax">
          $$
          (\Pi_{x : X} \Sigma_{x : A(x)} P(x, a)) \rightarrow (\Sigma_{g : \Pi_{x : A} A(x)} \Pi_{x : X} P(x, g(x)))
          $$
        </div>
        <p>
          Note that <span class="mathjax">$\Sigma_{g : \Pi_{x : X} A(x)} \Pi_{x : X} P(x, g(x))$</span> can be read as "there exists a choice function <span class="mathjax">$g : \Pi_{x : X} A(x)$</span> such that for all <span class="mathjax">$x : X$</span>, we have <span class="mathjax">$P(x, g(x))$</span>". The classical mathemtician may find that the axiom of choice doesn't carry its usual meaning.
        </p>
        <p>
          In the case of cartesian products, the non-dependent version simply expresses the <mark>cartesian closure adjuction</mark>:
        </p>
        <div class="mathjax">
          $$
          ((A \times B) \rightarrow C) \simeq (A \rightarrow (B \rightarrow C))
          $$
        </div>
        <p>
          Some other induction principles are also part of universal properties of this sort. For instance, path induction is the right-to-left direction of an equivalence as follows:
        </p>
        <div class="mathjax">
          $$
          (\Pi_{x : A}\Pi_{p : a = x} B(x, p)) \simeq B(a, \texttt{refl}_a)
          $$
        </div>
        <p>
          However, for inductive types with recursion, such as natural numbers, have more complicated universal properties, as we intend to describe later.
        </p>
        <p>
          As such, we have described the usual universal property of a cartesian product, but the reader may wonder about <mark>limits</mark> and <mark>colimits</mark> of types. For <mark>pullbacks</mark>, the expected explicit construction works; given <span class="mathjax">$f: A \rightarrow C$</span> and <span class="mathjax">$g : B \rightarrow C$</span>, we define:
        </p>
        <div class="mathjax">
          $$
          A \times_C B :\equiv \Sigma_{a : A}\Sigma_{b : B} (f(a) = g(b))
          $$
        </div>
        <p>
          For colimits, however, we need a new ingredient, which we will discuss later.
        </p>
      </article>
    </main>
  </body>
</html>