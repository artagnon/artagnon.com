<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Inside a register allocator | artagnon.com</title>
    <meta charset="utf-8" />
    <meta name="description" content="Ramkumar Ramachandra&#39;s personal website" />
    <meta name="HandheldFriendly" content="true" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index,follow" />
    <link rel="icon" href="/dist/artagnon.com.svg" />
    <link rel="mask-icon" href="/dist/mask-icon.svg" color="#000000" />
    <link rel="stylesheet" href="/dist/style.min.css" />
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/cash/6.0.1/cash.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.35/dayjs.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.35/plugin/relativeTime.min.js"></script>
    <script defer="" src="//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
    <script>
      MathJax = {
        loader: {
          load: ['[custom]/xypic.min.js'],
          paths: {custom: '/dist'}
        },
        tex: {
          packages: {'[+]': ['xypic']},
          inlineMath: [['$', '$']]
        }
      };
    </script>
    <link rel="preload" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/solarized-light.min.css" as="style" onload="this.onload=null;this.rel=&#39;stylesheet&#39;" />
    <noscript>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/solarized-light.min.css" />
    </noscript>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/coq.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/cpp.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/haskell.min.js"></script>
    <script defer="" src="/dist/script.min.js"></script>
  </head>
  <body>
    <nav>
      <div>
        <a href="/"><img src="/dist/artagnon.com.svg" alt="home" /></a>
      </div>
      <div>
        <ul>
          <li>
            <a href="/articles">articles</a>
          </li>
          <li>
            <a href="/computing">computing</a>
          </li>
          <li>
            <a href="/math">math</a>
          </li>
        </ul>
      </div>
    </nav>
    <main>
      <header class="wrapper">
        <h1>
          Inside a register allocator
        </h1>
        <div id="metadata">
          <span id="timestamp"><time datetime="2016-03-24" class="begin">Thu, 24 Mar 2016 17:36:35 -0500</time><span class="to">â†ª</span><time datetime="2020-12-17" class="end">Thu, 17 Dec 2020 03:04:07 +0100</time></span><br /><span id="locations"><address>Paris, Chennai, Boston</address></span>
        </div>
      </header>
      <article class="wrapper">
        <p>
          We are going to be discussing LLVM's Fast Register Allocator: you might like to open <a href="https://github.com/llvm-mirror/llvm/blob/master/lib/CodeGen/RegAllocFast.cpp">RegAllocFast.cpp</a> and refer to it as we go through the article.
        </p>
        <p>
          FastRegAlloc allocates linearly, going through instructions and their operands in order. It uses <mark>PhysRegState</mark> to keep track of the state of various physical registers: they can be 0 (<mark>regDisabled</mark>), 1 (<mark>regFree</mark>), 2 (<mark>regReserved</mark>), or a virtual register number (a large number). At the time of allocation, the full UseDef information is available (so you have information like <mark>LR.LastUse</mark>); a register can either be a <mark>&lt;def&gt;</mark> or a use. If <mark>IsImplicit</mark> is flipped, it could also be a implicit-def (<mark>&lt;imp-def&gt;</mark>) or implicit-use (<mark>&lt;imp-use&gt;</mark>).
        </p>
        <pre><code class="hljs cpp">%vreg349&lt;def&gt; = MOVZX32rm8 %vreg351, 1, %noreg, 0, %noreg</code></pre>
        <p>
          turns into
        </p>
        <pre><code class="hljs cpp">%ESI&lt;def&gt; = MOVZX32rm8 %RDX&lt;kill&gt;, 1, %noreg, 0, %noreg</code></pre>
        <p>
          after allocation. The <mark>&lt;kill&gt;</mark> indicates that the instruction is the last use of <mark>%RDX</mark>. In another example,
        </p>
        <pre><code class="hljs cpp">CQO %RAX&lt;imp-def&gt;, %RDX&lt;imp-def&gt;, %RAX&lt;imp-use&gt;</code></pre>
        <p>
          turns into
        </p>
        <pre><code class="hljs cpp">CQO %RAX&lt;imp-def&gt;, %RDX&lt;imp-def&gt;, %RAX&lt;imp-use,kill&gt;</code></pre>
        <p>
          Notice that the instruction references physical registers even before the allocation. That's because this instruction specifically wants to sign extend <mark>%RAX</mark> into <mark>%RDX</mark> (not any other register) for use in a later <mark>IDIV</mark>. Remember that <mark>IDIV</mark> operates on <mark>%RDX:%RAX</mark> as the numerator, and writes the quotient in <mark>%RAX</mark>, reminder in <mark>%RDX</mark>.
        </p>
        <p>
          The instruction is modeled as <mark>MachineInstr</mark>, and the operands as <mark>MachineOperand</mark>. Note that a <mark>MO</mark> doesn't have to be a register: it could also be an immediate value; we use <mark>MO.isReg()</mark> to find out if it's a register, physical or virtual. In addition to the states shown in the pretty-print, <mark>MO</mark> can also be <mark>EarlyClobber</mark>, <mark>Dead</mark>, or <mark>Undef</mark>. A Dead <mark>MO</mark> implies Def, and<br/>
          indicates that the value defined is used no longer.
        </p>
        <p>
          <mark>AllocateBasicBlock</mark>, which operates on <mark>MachineBasicBlock</mark>, can be separated into three different scans, that operate on register MOs. Before the first scan, we set up the <mark>LiveIns</mark> (registers coming in live from the previous <mark>MBB</mark>) as <mark>regReserved</mark> so they aren't clobbered. The first scan operates on physical registers that are allocatable Uses; it calls <mark>usePhysReg</mark> on them. At this stage, the physical register must be either <mark>regDisabled</mark>, <mark>regReserved</mark>, or <mark>regFree</mark>. It cannot be allocated to a virtual register. Why? Imagine you see:
        </p>
        <pre><code class="hljs cpp">CQO %RAX&lt;imp-def&gt;, %RDX&lt;imp-def&gt;, %RAX&lt;imp-use&gt;</code></pre>
        <p>
          Now, if <mark>%RAX</mark> were already allocated to a virtual register, we're basically screwed in this linear walk. Otherwise, kill it, mark it as <mark>regFree</mark>, and move on: we have done our part by completing the use of the register that was reserved earlier.
        </p>
        <p>
          The second scan operates only on virtual register Uses. We add the register to <mark>LiveVirtRegs</mark>, via <mark>reloadVirtReg</mark>. If it didn't already exist in the map, we <mark>allocVirtReg</mark> it, which essentially gets the first <mark>regFree</mark> register not used in an instruction, and calls <mark>assignVirtToPhysReg</mark> on it. <mark>assignVirtToPhysReg</mark> is very simple: it just updates the <mark>PhysRegState</mark> mapping. Finally,<br/>
          <mark>reloadVirtReg</mark> updates the <mark>UsedInInstr</mark> map.
        </p>
        <p>
          The third scan operates on physical and virtual registers that are Defs. If the register is a physical register, it does <mark>definePhysReg</mark> with <mark>regReserved</mark> unless <mark>MO.isDead()</mark>, in which case it's regFree. <mark>definePhysReg</mark> is very simple: it just puts the register in the state that was requested (<mark>regReserved</mark> or <mark>regFree</mark>, in this case).
        </p>
        <p>
          To think about the problem, if we have,
        </p>
        <pre><code class="hljs cpp">%RAX&lt;def&gt; = COPY %vreg342</code></pre>
        <p>
          we should always <mark>regReserve</mark> <mark>%RAX</mark>, right? Except if <mark>%RAX</mark> is dead. What<br/>
          about if it's an <mark>&lt;imp-def&gt;</mark>?
        </p>
        <pre><code class="hljs cpp">CQO %RAX&lt;imp-def&gt;, %RDX&lt;imp-def&gt;, %RAX&lt;imp-use&gt;</code></pre>
        <p>
          We didn't pass <mark>CQO</mark> <mark>%RAX</mark> explicitly, but that doesn't mean that a later instruction (for instance, <mark>IDIV</mark>) is not relying on this register's value. If we have an instruction between <mark>CQO</mark> and <mark>IDIV</mark>, that can potentially clobber <mark>%RAX</mark>, leading to a regalloc crash. Hence, we <mark>regReserve</mark> even if <mark>MO.isImplicit()</mark>.
        </p>
        <p>
          The third scan does <mark>defineVirtReg</mark> on virtual registers, to grab the first free physical register for the virtual register.
        </p>
        <p>
          Note: the "pretty-prints" are generated by setting a breakpoint in <mark>AllocateBasicBlock</mark> and executing <mark>p MBB-&gt;dump()</mark>.
        </p>
      </article>
    </main>
  </body>
</html>