Equality in Mechanized Mathematics

...
Here, we talk about equalities, and provide illustrative examples in vanilla Coq, SProp, and HoTT.
...

# Equality in Mathematics

In [zfc-based Mathematics](/zfc), say in abelian groups, $A \oplus B = B \oplus A$, where the equality is a set-based equality. In modern mathematics based on category theory, we only speak of objects that are "unique upto isomorphism"; when objects are sets, isomorphism asks for a bijection between the two sets. In higher categories, and in particular, homotopy theory, we talk about "weak homotopy equivalences" completely replacing equality. However, it can be tricky to mechanize a theory based on $\infty$-categories; the best dependent-type-theory model we have is homotopy type theory.

# Universes in Coq

First, let us briefly talk about the cumulative universe of Coq. `Prop` and `Set` are disjoint, but can be promoted to `Type` seamlessly. The reason for the disjoin is essentially an engineering one: `Prop` is impredicative, while `Set` is not, and proofs are erased during extraction.

~~
Goal SetTypeCum : Set -> Type.
  auto.
Qed.

Goal PropTypeCum : Prop -> Type.
  auto.
Qed.

Goal SetPropDisjoint : Set -> Prop.
Abort.
~~

There is an $\infty$ hierarchy within the `Type` universe, and types of Types are Types themselves.

Inhabitants of a `Set` are sets of things like `nat`, while inhabitants of a `Prop` are propositions, which could be $\top$, $\bot$, or some arbitrary term, the inhabitant of which acts as the proof.

# The proof-relevant Prop

There are two kinds of equalities in vanilla Coq. The difference is as follows: propositional equality roughly translates to "requires proof obligation to be discharged by the user", while definitional equality is a simple syntactic rewriting in the metatheory. A propositional equality can be formalized as:

~~
Axiom PropositionalEquality : forall (P : Prop) (a b : P), a = b.
~~

then, we get a proof obligation which we discharge using the axiom:

~~
Theorem PropEquality (P : Prop) (a b : P) : a = b.
Proof.
  by apply PropositionalEquality.
Qed.
~~

`Prop` is proof-relevant, which means that two different inhabitants of propositions are unequal, although reasoning about the relationship between two different propositions is tedious at best. There is, however, a propositional equality existing between two equal propositions:

~~
Theorem PropRefl (P : Prop) (x : P): x = x.
  exact eq_refl.
Qed.
~~

where `eq_refl` is simply the sole inhabitant of an `Inductive`:

~~
Inductive eq (A : Type) (x : A) : A -> Prop :=
  eq_refl : eq A x x.
~~

# The proof-irrelevant SProp

There are three inhabitants of [SProp](https://coq.inria.fr/refman/addendum/sprop.html): `sUnit` corresponding to $\top$, `sEmpty` corresponding to $\bot$, and `sProposition` corresponding to a definitionally proof-irrelevant term. The way `SProp` implements definitional proof-irrelevance is a simple engineering detail: there is hard-coding in Coq to render two inhabitants of `sPropoposition` trivially inter-convertible.

Unfortunately, `=` doesn't work as expected:

~~
Theorem SPropIrr (P : SProp) (x y : P) : x = y.
Proof.
  by reflexivity.
Abort. (* Type-check fails at Qed.
        * (=) : forall A, A -> A -> Prop, but we want to return an SProp. *)
~~

This is because the `SProp` universe is disjoint from the `Prop` universe:

~~
Theorem SPropToProp : SProp -> Prop.
Proof.
  by intros x; exact x.
Abort. (* Type-check fails at Qed.
        * SProp is not convertible to Prop. *)
~~

Fortunately, we can do better.

# Mere propositions in homotopy type theory

In [HoTT](https://github.com/HoTT/HoTT), a "mere proposition", an inhabitant of `hProp`, is simply a ($\mathrm{-1}$)-truncated Type, where $\mathbb{1}$ (and anything that's contractible to $\mathbb{1}$) is the ($\mathrm{-2}$)-truncated Type, and `Set` can be approximated by `hSet`, the $\mathrm{0}$-truncated type.

~~
Notation Contr := (IsTrunc (minus_two)).
Notation IsHProp := (IsTrunc (minus_two.+1)).
Notation IsHSet := (IsTrunc minus_two.+2).
~~

The notion of truncation is central to HoTT, where $A : \mathrm{Type}_n$ can be truncated to a $\mathrm{Type}_m$, where higher-than-$m$ morphisms are rendered uninteresting. By propositional truncation, any two hProps are propositionally equal:

~~
Theorem hPropEquality (P : hProp) (a b : P) : a = b.
Proof.
  by apply path_ishprop.
Qed.
~~

Conceptually, this is as simple and elegant as `PropEquality`.

† Big thanks to [Kenji Maillard](https://kenji.maillard.blue) for the scintillating discussion, and for helping with the examples.
‡ Kudos to Hugo Moeneclaey for giving a wonderful introduction to truncation in the last HoTT class.
