An inquiry into type systems

...
In this article, we ask fundamental questions about type systems, using programming language syntax similar to Coq, and standard mathematical notation. The type system we propose is a variation of HoTT.
...

A type is a $\textbf{Set}$ of inhabitants and a proposition relating the inhabitants. Propositions are types themselves, while inhabitants could be types or, in the degenerate case, a $\textbf{Set}$ of inhabitants. We define it this way to disallow nonsensical definitions like $0 : \textbf{Type}$ and $0 : \textbf{Prop}$. In

~~
x : Set.
~~

$\textbf{Set}$ is a type that contains its inhabitants, with no proposition between the inhabitants. Think of it as a bag of scrabble pieces, such that there is no relationship between the pieces. One can, of course, build multiple types from the same $\textbf{Set}$ by imposing different structures on the inhabitats; for instance, $\mathbb{Z}$ could have a group structure, a ring structure, or even a simple total order:

{{
  \ldots\ar[r]^{<} & -2\ar[r]^{<} & -1\ar[r]^{<} & 0 \ar[r]^{<} & 1 \ar[r]^{<} & 2 \ar[r]^{<} & \ldots
}}

This can be formalized as $\Pi a. \Sigma b. a < b$ or $\forall a, \exists b, a < b$, which has two inhabitants $a$ and $b$, along with a proposition relating the two inhabitants. In general, it is impossible to say if a proposition is inhabitable, as it is equivalent to asking the question if a certain lemma can be proved: the only way to find out is to try and construct a proof.

Let us now investigate functions. $\mathbb{N} \twoheadrightarrow \mathbb{R}$ is an epic function from a type of lower cardinality to a type of higher cardinality; this function type is nonsensical, or uninhabited. Any function is simply a desugaring of a $\Pi$ type; for instance `+` is:

~~
+ : nat -> nat -> nat.
+ : forall nat, nat -> nat.
+ : forall nat, forall nat, nat.
~~

To understand this better, let us use the following equivalent definition, which works only because the second argument is independent of the first:

~~
+ : forall nat * nat : nat.
~~

{{
  a\ar[r]^{\iota_1}\ar[rd] & a \times b\ar@{.>}[d]|{\exists! e} & b\ar[l]_{\iota_2}\ar[ld] \\
  & p\ar[d]|{+} \\
  & r
}}

Non-dependent $\Pi$ types are easy to understand, but raises the question about how $\Sigma$ and $\Pi$ are actually defined:

TODO

Raising the level of abstraction, the following is also a function type, which one would think of as a proposition:

~~
trans< : forall {a b c}, a < b -> b < c -> a < c.
~~

Now, we investigate the question of constructing new types from old ones; we have already seen $\Sigma$ and $\Pi$ types. Generally speaking, the operations available for constructing target types depends on the source types. In the case of rings and prime ideals, $\mathbb{Z}_p := \mathbb{Z}/\mathbb{Z} p$. This is an abelian group inhabitated by a poset, with the following additional propositions imposed, where $\circ$ is $+$, and $e$ is $0$:

$$
  \forall a, a \circ e = e \circ a = a \\
  \forall a, \exists a^{-1}, a \circ a^{-1} = a^{-1} \circ a = e \\
  \forall a b, a \circ b = b \circ a
$$

Indeed, $/$ is a function $\textbf{Rng} \rightarrow \textbf{Ideal} \rightarrow \textbf{Ab}$. It erases some of the structure in the ring in a precise way. Another example of a function that systematically erases structure is the forgetful functor $\mathfrak{F} : \textbf{Top} \rightarrow \textbf{Set}$.

Now, consider a chaotic type like $\{n : \mathbb{Z}_p \mid n > 1\}$; this is a "subtype" of $\mathbb{Z}_p$, but we have erased the identity element, and there is no systematic way of saying what structure is preserved in the destination type. Therefore, in the general case, this would be desugared to:

$$
  \textrm{trunc} : \textbf{Type} \hookrightarrow \textbf{Set}. \\
  \{n : \mathbb{Z}_p \mid n > 1\} := \{n : \textrm{trunc} (\mathbb{Z}_p) \mid n > 1\}.
$$

Since there is only one possible definition of `trunc`, the above definition is complete. In the same spirit of ad-hoc types, we could accomodate $\textbf{Set} + \textbf{Empty}$, a desugaring of the "option" type.

To investigate partial applications of functions, or "currying":

~~
+ : nat -> nat -> nat.
+a {a} : nat -> nat := + a.
~~

First, desugar:

~~
+ : forall nat . nat -> nat.
~~
