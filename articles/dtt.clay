Dependent types in everyday programming

Chances are you've seen a non-trivial proof of `x + y = y + x`, and turned off by the fact that real-world programs don't care for such trivialities. Yes, it is true that dependent type systems are in their infancy, and are, for the most part, used just in proof assistants. In this article, we argue that everday programming can benefit greatly from a sophisticated type system derived simple underlying principles. We'll start with some motivating examples, introduce homotopy type theory (HoTT), and end with future directions.

# A pedestrian example

Let's say you've written a complex serialization routine, and want to check that it does the right thing:

```hs
serialize :: Bytes -> Bytes
deserialize :: Bytes -> Bytes
test_ser :: Bytes -> Bool
  deserialize . serialize $ x == x
```

There are several problems with this code. First, the types are wrong: a serializable type isn't a deserializable type. Second, `test_ser` only checks the composition of `deserialize` with `serialize`, not the other way around. Third, you can never really be guaranteed that `test_ser` works: the best you can do is to write some more code to craft `x`, hope that it's correct, and run QuickCheck with a large number of times, and hope that you've covered everything. Let's try improving upon this:

```hs
serialize :: (Serializable a, Deserializable b) => a -> b
deserialize :: (Serializable a, Deserializable b) => b -> a
test_ser :: (Serializable a) => a -> Bool
  deserialize . serialize $ x == x
test_deser :: (Deserializable a) => a -> Bool
  deserialize . serialize $ x == x
```

You now have to write the `Serializable` and `Deserializable` typeclasses, and an additional QuickCheck input for deserializable types. This is classic code-bloat, and you're still not guaranteed that it works. What you really want is:

~~
Definition serialize : `{Serlializable a} (a : Bytes) : Bytes.
Instance isequiv_serialize : IsEquiv serialize.
Definition deserialize := serialize ^-1.
~~

Correct by definition, and there's one typeclass `Serlializable` and one proof we need to write about the invertibility of `serialize`. There's a lot of machinery that we need to study before we can make this work, and a dependent type system is a really basic requirement.

# A second example

~~
Record Parser :=
{
  f1 : Bytes;
  f2 : Bytes;
}.
~~

# A HoTT primer

HoTT is based on a solid mathematical foundation, but a simple abbreviated version will do for our purposes. See [this](/HoTT) for a slightly deeper look.

Let's start again with a simple motivating example:

~~
{A, B : Type}
{x, y : A}
{P, Q : Prop}
{f, g : A -> B}
{P f g}
{Q x y}
~~

Simple case:

~~
Theorem refl_refl : P = refl /\ Q = refl -> R = refl.
~~

You'd write a proof for this, but let's consider the more general case when `P` and `Q` are complicated propositions, and you don't want to spend time constructing `R` and proving it, but rather, you want some general relationship between `f(x)` and `g(y)`. Without looking inside `P` and `Q`, this would be impossible.

(a) Types are topological spaces. Thinking in terms of point-set topology, inhabitants of types are subspaces of the topological space, which are also topological spaces; in the degenerate case, they could just be points like `True` and `False` in $\mathbb{B}$.
(b) A function is a homotopy between topological spaces. For instance, a function could take a `List` and construct a `BTree` out of it. The underlying inhabitants at the very bottom are the same: a set of natural numbers.
(c) A homotopy between spaces maps one topological space to another topological space. Say the topological space $\mathbb{Z}$ to the topological space $\mathbb{N}$.
(d) Consider two functions (or homotopies) $f$ and $g$. To say that they're homotopy equivalent means that they have the same start and end points: $f \sim g$. The path that `f` traverses in space from the starting point to the end point can be continuously deformed to the path that $g$ traverses. The "points" could simply be sets, but they could also be higher homotopies.
(e) Homotopy equivalence is a proof, which is also a homotopy between inhabitants.

# A cubical solver

~~
Record Cubical {n : nat} :=
{
  csp {n'} (Hn' : n' <= n) : Type@{l'} ;
  hd {n'} {Hn' : S n' <= n} : csp Hn' -> csp (â‡“ Hn') ;
  box {n' p} {Hn' : n' <= n} (Hp : p <= n') : csp Hn' -> Type@{l} ;
}.
~~

# Propositions as the bread-and-butter of programs

# Conclusions
