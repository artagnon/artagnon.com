<!DOCTYPE html>
<html>
  <head>
    <title>Equality in Mechanized Mathematics | artagnon.com</title>
    <meta charset="utf-8" />
    <meta name="language" content="english" />
    <meta name="author" content="Ramkumar Ramachandra" />
    <meta name="city" content="Paris" />
    <meta name="country" content="France" />
    <meta name="keywords" content="mathematics, mathematical notes, study notes, programming, blog, personal website" />
    <meta name="HandheldFriendly" content="true" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index,follow" />
    <link rel="stylesheet" href="/dist/style.min.css" />
    <script src="//ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
    <script>
      WebFont.load({
        google: {
          families: ['Josefin Sans', 'Roboto Mono']
        }
      });
    </script>
    <link rel="icon" href="/dist/favicon.ico" />
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-5837870-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async="" src="//www.google-analytics.com/analytics.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/cash/6.0.1/cash.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      extensions: ["tex2jax.js"], jax: ["input/TeX","output/HTML-CSS"],
      "HTML-CSS": { styles: {".MathJax_Preview": {visibility: "hidden"}} },
      tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]},
      TeX: {extensions: ["/dist/xypic.min.js","AMSmath.js","AMSsymbols.js"]} });
    </script>
    <link rel="preload" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/solarized-light.min.css" as="style" onload="this.onload=null;this.rel=&#39;stylesheet&#39;" />
    <noscript>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/solarized-light.min.css" />
    </noscript>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/coq.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script defer="" src="/dist/script.min.js"></script>
  </head>
  <body>
    <div id="wrapper">
      <main tabindex="0">
        <header>
          <h1>
            Equality in Mechanized Mathematics
          </h1>
          <div id="metadata">
            <span id="timestamp"><time datetime="2020-02-15" class="begin">Sat, 15 Feb 2020 18:12:59 +0100</time><span class="to">↪</span><time datetime="2020-02-16" class="end">Sun, 16 Feb 2020 10:20:40 +0100</time></span><br /><span id="locations"><address>Paris</address></span>
          </div>
        </header>
        <article>
          <p class="blurb">
            Here, we talk about equalities, and provide illustrative examples in vanilla Coq, SProp, and HoTT.
          </p>
          <h2 id="equality-in-mathematics">
            Equality in Mathematics
          </h2>
          <p>
            In zfc-based Mathematics, say in abelian groups, $A \oplus B = B \oplus A$, where the equality is a [set-based equality](/zfc). In modern mathematics based on category theory, we only speak of objects that are "unique upto isomorphism". In higher categories, and in particular, homotopy theory, we talk about "weak homotopy equivalences" completely replacing equality. However, it can be tricky to mechanize a theory based on $\infty$-categories, and model in dependent type theory is needed.
          </p>
          <h2 id="universes-in-coq">
            Universes in Coq
          </h2>
          <p>
            First, let us briefly talk about the cumulative universe of Coq. `Prop` and `Set` are disjoint, but can be promoted to `Type` seamlessly. The reason for the disjoin is essentially an engineering one: `Prop` is impredicative, while `Set` is not, and proofs are erased during extraction.
          </p>
          <pre><code class="language-coq">Goal SetTypeCum : Set -> Type.
  auto.
Qed.

Goal PropTypeCum : Prop -> Type.
  auto.
Qed.

Goal SetPropDisjoint : Set -> Prop.
Abort.</code></pre>
          <p>
            There is an $\infty$ hierarchy within the `Type` universe, and types of Types are Types themselves.
          </p>
          <p>
            Inhabitants of a `Set` are sets of things like `nat`, while inhabitants of a `Prop` are propositions, which could be $\top$, $\bot$, or some arbitrary term, the inhabitant of which acts as the proof.
          </p>
          <h2 id="the-proof-relevant-prop">
            The proof-relevant Prop
          </h2>
          <p>
            There are two kinds of equalities in vanilla Coq. The difference is as follows: propositional equality roughly translates to "requires proof obligation to be discharged by the user", while definitional equality is a simple syntactic rewriting. A propositional equality can be formalized as:
          </p>
          <pre><code class="language-coq">Axiom PropositionalEquality : forall (P : Prop) (a b : P), a = b.</code></pre>
          <p>
            then, we get a proof obligation which we discharge using the axiom:
          </p>
          <pre><code class="language-coq">Theorem PropEquality (P : Prop) (a b : P) : a = b.
Proof.
  by apply PropositionalEquality.
Qed.</code></pre>
          <p>
            `Prop` is proof-relevant, which means that two different inhabitants of propositions are unequal. There is, however, a propositional equality existing between two equal propositions:
          </p>
          <pre><code class="language-coq">Theorem PropRefl (P : Prop) (x : P): x = x.
  exact eq_refl.
Qed.</code></pre>
          <p>
            where `eq_refl` is simply the sole inhabitant of an `Inductive`:
          </p>
          <pre><code class="language-coq">Inductive eq (A : Type) (x : A) : A -> Prop :=
  eq_refl : eq A x x.</code></pre>
          <h2 id="the-proof-irrelevant-sprop">
            The proof-irrelevant SProp
          </h2>
          <p>
            There are three inhabitants of [SProp](https://coq.inria.fr/refman/addendum/sprop.html): `sUnit` corresponding to $\top$, `sEmpty` corresponding to $\bot$, and `sProposition` corresponding to a definitionally proof-irrelevant term. The way `SProp` implements definitional proof-irrelevance is a simple engineering detail: there is hard-coding in Coq to render two inhabitants of `sPropoposition` trivially inter-convertible.
          </p>
          <p>
            `=` doesn't work as expected:
          </p>
          <pre><code class="language-coq">Theorem SPropIrr (P : SProp) (x y : P) : x = y.
Proof.
  by reflexivity.
Abort. (* Type-check fails at Qed.
        * (=) : forall A, A -> A -> Prop, but we want to return an SProp. *)</code></pre>
          <p>
            This is because the `SProp` universe is disjoint from the `Prop` universe:
          </p>
          <pre><code class="language-coq">Theorem SPropToProp : SProp -> Prop.
Proof.
  by intros x; exact x.
Abort. (* Type-check fails at Qed.
        * SProp is not convertible to Prop. *)</code></pre>
          <p>
            Highly inelegant, but avoids the complication of completely overhauling the type system in Coq.
          </p>
          <h2 id="mere-propositions-in-homotopy-type-theory">
            Mere propositions in homotopy type theory
          </h2>
          <p>
            In [HoTT](https://github.com/HoTT/HoTT), a "mere proposition", an inhabitant of `hProp`, is simply a ($\mathrm{-1}$)-truncated Type, where $\mathbb{1}$ (and anything that's contractible to $\mathbb{1}$ is the ($\mathrm{-2}$)-truncated Type, and `Set` can be approximated by `hSet`, the $\mathrm{0}$-truncated type.
          </p>
          <pre><code class="language-coq">Notation Contr := (IsTrunc (minus_two)).
Notation IsHProp := (IsTrunc (minus_two.+1)).
Notation IsHSet := (IsTrunc minus_two.+2).</code></pre>
          <p>
            The notion of truncation is central to HoTT, where $A : \mathrm{Type}_n$ can be truncated to a $\mathrm{Type}_m$, where higher-than-$m$ morphisms are rendered uninteresting. By propositional truncation, any two hProps are propositionally equal:
          </p>
          <pre><code class="language-coq">Theorem hPropEquality (P : hProp) (a b : P) : a = b.
Proof.
  by apply path_ishprop.
Qed.</code></pre>
          <p>
            Conceptually, this is as simple and elegant as `PropEquality`.
          </p>
          <footer>
            <p>
              † Big thanks to [Kenji Maillard](https://kenji.maillard.blue) for the scintillating discussion, and for helping with the examples.
            </p>
            <p>
              ‡ Kudos to Hugo Moeneclaey for giving a wonderful introduction to truncation in the last HoTT class.
            </p>
          </footer>
        </article>
      </main>
      <nav>
        <ul>
          <li>
            <a href="/index">index</a>
          </li>
          <li>
            <a href="/ag">ag</a>
          </li>
          <li>
            <a href="/algebra">algebra</a>
          </li>
          <li>
            <a href="/articles">articles</a>
          </li>
          <li>
            <a href="/attic">attic</a>
          </li>
          <li>
            <a href="/category">category</a>
          </li>
          <li>
            <a href="/topoi">topoi</a>
          </li>
          <li>
            <a href="/topology">topology</a>
          </li>
          <li>
            <a href="/zfc">zfc</a>
          </li>
        </ul>
      </nav>
    </div>
  </body>
</html>