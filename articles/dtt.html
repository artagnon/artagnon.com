<!DOCTYPE html>
<html>
  <head>
    <title>The structure of Types | artagnon.com</title>
    <meta charset="utf-8" />
    <meta name="language" content="english" />
    <meta name="author" content="Ramkumar Ramachandra" />
    <meta name="city" content="Paris" />
    <meta name="country" content="France" />
    <meta name="keywords" content="mathematics, mathematical notes, study notes, programming, blog, personal website" />
    <meta name="HandheldFriendly" content="true" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index,follow" />
    <link rel="icon" href="/dist/favicon.ico" />
    <link rel="stylesheet" href="/dist/style.min.css" />
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/cash/6.0.1/cash.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.35/dayjs.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.35/plugin/relativeTime.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      extensions: ["tex2jax.js"], jax: ["input/TeX","output/HTML-CSS"],
      "HTML-CSS": { styles: {".MathJax_Preview": {visibility: "hidden"}} },
      tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]},
      TeX: {extensions: ["/dist/xypic.min.js","AMSmath.js","AMSsymbols.js"]} });
    </script>
    <link rel="preload" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/solarized-light.min.css" as="style" onload="this.onload=null;this.rel=&#39;stylesheet&#39;" />
    <noscript>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/solarized-light.min.css" />
    </noscript>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/coq.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/cpp.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/haskell.min.js"></script>
    <script defer="" src="/dist/script.min.js"></script>
  </head>
  <body>
    <div id="wrapper">
      <nav>
        <ul>
          <li>
            <a href="/index">home</a>
          </li>
          <li>
            <a href="/HoTT">HoTT</a>
          </li>
          <li>
            <a href="/ag">ag</a>
          </li>
          <li>
            <a href="/algebra">algebra</a>
          </li>
          <li>
            <a href="/articles">articles</a>
          </li>
          <li>
            <a href="/at">at</a>
          </li>
          <li>
            <a href="/attic">attic</a>
          </li>
          <li>
            <a href="/category">category</a>
          </li>
          <li>
            <a href="/topoi">topoi</a>
          </li>
          <li>
            <a href="/∞">∞</a>
          </li>
        </ul>
      </nav>
      <main>
        <header>
          <h1>
            The structure of Types
          </h1>
          <div id="metadata">
            <span id="timestamp"><time datetime="2020-10-04" class="begin">Sun, 04 Oct 2020 00:29:33 +0200</time><span class="to">↪</span><time datetime="2020-10-11" class="end">Sun, 11 Oct 2020 15:03:21 +0200</time></span><br /><span id="locations"><address>Paris</address></span>
          </div>
        </header>
        <article>
          <p class="blurb">
            In this article, we ask fundamental questions about type systems, using an imaginary programming language syntax similar to Coq, and standard mathematical notation. The type system in question is an imaginary variant of HoTT.
          </p>
          <p>
            A type is a $\textbf{Set}$ of inhabitants and a proposition relating the inhabitants. Propositions are types themselves, while inhabitants could be types or, in the degenerate case, a $\textbf{Set}$ of inhabitants. We define it this way to disallow nonsensical definitions like $0 : \textbf{Type}$ and $0 : \textbf{Prop}$. In
          </p>
          <pre><code class="coq">x : Set.</code></pre>
          <p>
            $\textbf{Set}$ is a type that contains its inhabitants, with no proposition between the inhabitants. Think of it as a bag of scrabble pieces, such that there is no relationship between the pieces. One can, of course, build multiple types from the same $\textbf{Set}$ by imposing different structures on the inhabitats; for instance, $\mathbb{Z}$ could have a group structure, a ring structure, or even a simple total order:
          </p>
          <p class="mathjax">
            $$
              \begin{xy}
              \xymatrix{
            
            \ldots\ar[r]^{<} & -2\ar[r]^{<} & -1\ar[r]^{<} & 0 \ar[r]^{<} & 1 \ar[r]^{<} & 2 \ar[r]^{<} & \ldots
              }
              \end{xy}
            
            $$
          </p>
          <p>
            This can be formalized as $\Pi a. \Sigma b. a &lt; b$ or $\forall a, \exists b, a &lt; b$, which has two inhabitants $a$ and $b$, along with a proposition relating the two inhabitants. In general, it is impossible to say if a proposition is inhabitable, as it is equivalent to asking the question if a certain lemma can be proved: the only way to find out is to try and construct a proof.
          </p>
          <p>
            Let us now investigate functions. $\mathbb{N} \twoheadrightarrow \mathbb{R}$ is an epic function from a type of lower cardinality to a type of higher cardinality; this function type is nonsensical, or uninhabited. Any function is simply a desugaring of a $\Pi$ type; for instance <mark>+</mark> is:
          </p>
          <pre><code class="coq">+ : nat -&gt; nat -&gt; nat.
+ : forall nat, nat -&gt; nat.
+ : forall nat, forall nat, nat.</code></pre>
          <p>
            To understand this better, let us use the following equivalent definition, which works only because the second argument is independent of the first:
          </p>
          <pre><code class="coq">+ : forall nat * nat : nat.</code></pre>
          <p class="mathjax">
            $$
              \begin{xy}
              \xymatrix{
            
            a\ar[r]^{\iota_1}\ar[rd] & a \times b\ar@{.>}[d]|{\exists! e} & b\ar[l]_{\iota_2}\ar[ld] \\
              & p\ar[d]|{+} \\
              & r
              }
              \end{xy}
            
            $$
          </p>
          <p>
            Non-dependent $\Pi$ types are easy to understand, but raises the question about how $\Sigma$ and $\Pi$ are actually defined:
          </p>
          <p>
            TODO
          </p>
          <p>
            Raising the level of abstraction, the following is also a function type, which one would think of as a proposition:
          </p>
          <pre><code class="coq">trans&lt; : forall {a b c}, a &lt; b -&gt; b &lt; c -&gt; a &lt; c.</code></pre>
          <p>
            Now, we investigate the question of constructing new types from old ones; we have already seen $\Sigma$ and $\Pi$ types. Generally speaking, the operations available for constructing target types depends on the source types. In the case of rings and prime ideals, $\mathbb{Z}_p := \mathbb{Z}/\mathbb{Z} p$. This is an abelian group inhabitated by a poset, with the following additional propositions imposed, where $\circ$ is $+$, and $e$ is $0$:
          </p>
          <p class="mathjax">
            $$
            \forall a, a \circ e = e \circ a = a \\
              \forall a, \exists a^{-1}, a \circ a^{-1} = a^{-1} \circ a = e \\
              \forall a b, a \circ b = b \circ a
            $$
          </p>
          <p>
            Indeed, $/$ is a function $\textbf{Rng} \rightarrow \textbf{Ideal} \rightarrow \textbf{Ab}$. It erases some of the structure in the ring in a precise way. Another example of a function that systematically erases structure is the forgetful functor $\mathfrak{F} : \textbf{Top} \rightarrow \textbf{Set}$.
          </p>
          <p>
            Now, consider a chaotic type like $\{n : \mathbb{Z}_p \mid n &gt; 1\}$; this is a "subtype" of $\mathbb{Z}_p$, but we have erased the identity element, and there is no systematic way of saying what structure is preserved in the destination type. Therefore, in the general case, this would be desugared to:
          </p>
          <p class="mathjax">
            $$
            \textrm{trunc} : \textbf{Type} \hookrightarrow \textbf{Set}. \\
              \{n : \mathbb{Z}_p \mid n > 1\} := \{n : \textrm{trunc} (\mathbb{Z}_p) \mid n > 1\}.
            $$
          </p>
          <p>
            Since there is only one possible definition of <mark>trunc</mark>, the above definition is complete. In the same spirit of ad-hoc types, we could accomodate $\textbf{Set} + \textbf{Empty}$, a desugaring of the "option" type.
          </p>
          <p>
            To investigate partial applications of functions, or "currying":
          </p>
          <pre><code class="coq">+ : nat -&gt; nat -&gt; nat.
+a {a} : nat -&gt; nat := + a.</code></pre>
          <p>
            First, desugar:
          </p>
          <pre><code class="coq">+ : forall nat . nat -&gt; nat.</code></pre>
        </article>
      </main>
    </div>
  </body>
</html>