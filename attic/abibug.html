<!DOCTYPE html>
<html>
  <head>
    <title>An ABI-mismatch bug | artagnon.com</title>
    <meta charset="utf-8" />
    <meta name="language" content="english" />
    <meta name="author" content="Ramkumar Ramachandra" />
    <meta name="city" content="Paris" />
    <meta name="country" content="France" />
    <meta name="keywords" content="mathematics, mathematical notes, study notes, programming, blog, personal website" />
    <meta name="HandheldFriendly" content="true" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index,follow" />
    <link rel="icon" href="/dist/favicon.ico" />
    <link rel="stylesheet" href="/dist/style.min.css" />
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/cash/6.0.1/cash.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.35/dayjs.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.35/plugin/relativeTime.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      extensions: ["tex2jax.js"], jax: ["input/TeX","output/HTML-CSS"],
      "HTML-CSS": { styles: {".MathJax_Preview": {visibility: "hidden"}} },
      tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]},
      TeX: {extensions: ["/dist/xypic.min.js","AMSmath.js","AMSsymbols.js"]} });
    </script>
    <link rel="preload" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/solarized-light.min.css" as="style" onload="this.onload=null;this.rel=&#39;stylesheet&#39;" />
    <noscript>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/solarized-light.min.css" />
    </noscript>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/coq.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/cpp.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/haskell.min.js"></script>
    <script defer="" src="/dist/script.min.js"></script>
  </head>
  <body>
    <div id="wrapper">
      <nav>
        <ul>
          <li>
            <a href="/index">home</a>
          </li>
          <li>
            <a href="/HoTT">HoTT</a>
          </li>
          <li>
            <a href="/ag">ag</a>
          </li>
          <li>
            <a href="/algebra">algebra</a>
          </li>
          <li>
            <a href="/articles">articles</a>
          </li>
          <li>
            <a href="/at">at</a>
          </li>
          <li>
            <a href="/attic">attic</a>
          </li>
          <li>
            <a href="/category">category</a>
          </li>
          <li>
            <a href="/topoi">topoi</a>
          </li>
          <li>
            <a href="/∞">∞</a>
          </li>
        </ul>
      </nav>
      <main>
        <header>
          <h1>
            An ABI-mismatch bug
          </h1>
          <div id="metadata">
            <span id="timestamp"><time datetime="2015-08-23" class="begin">Sun, 23 Aug 2015 16:25:56 -0500</time><span class="to">↪</span><time datetime="2020-10-08" class="end">Thu, 08 Oct 2020 23:21:05 +0200</time></span><br /><span id="locations"><address>Paris, Chennai, Boston</address></span>
          </div>
        </header>
        <article>
          <p>
            Our custom max function returns the maximum of two positive integers, and returns the negative integer, given a positive and negative integer. Classic signed wrapping, you'd think. It's not so simple, as the problem reproduces only under the following circumstances:
          </p>
          <ol class="olitems" type="none" start="1">
            <li>
              LLVM code is calling the max function.
            </li>
            <li>
              The library containing the max function is compiled without debugging information.
            </li>
            <li>
              The entire world has been built with XCode 6+.
            </li>
          </ol>
          <p>
            More information: The LLVM IR is exactly the same between an XCode 5 sandbox, an XCode 6 sandbox, and a GNU/Linux sandbox. The corresponding assembly diff is also clean.
          </p>
          <p>
            The corresponding C++ code (is actually specialized with short) is:
          </p>
          <pre><code class="cpp">template &lt;typename T&gt;
FORCEINLINE T operator()(T a, T b) const
{
   return (a &gt;= b ? a : b);
}</code></pre>
          <p>
            While in lldb, the assembly instructions look like:
          </p>
          <pre><code class="cpp">--------------- [XCode 5]
-&gt; 0x108af1930:  pushq  %rbp
   0x108af1931:  movq   %rsp, %rbp
   0x108af1934:  cmpw   %si, %di
   0x108af1937:  cmovgew %di, %si
   0x108af193b:  movswl %si, %eax
   0x108af193e:  popq   %rbp
   0x108af193f:  retq</code></pre>
          <pre><code class="cpp">--------------- [XCode 6]
-&gt; 0x108d1ac10:  pushq  %rbp
   0x108d1ac11:  movq   %rsp, %rbp
   0x108d1ac14:  cmpl   %esi, %edi
   0x108d1ac16:  cmovgew %di, %si
   0x108d1ac1a:  movswl %si, %eax
   0x108d1ac1d:  popq   %rbp
   0x108d1ac1e:  retq</code></pre>
          <p>
            So, it's comparing the extended registers, but cmpl/cmpw difference is<br/>
            messing up somehow.
          </p>
          <p>
            After execution of the cmpl/cmpw:
          </p>
          <pre><code class="cpp">--------------- [XCode 5]
(lldb) register read --format int16_t[] di
      di = {-48}
(lldb) register read --format int16_t[] si
      si = {34}
(lldb) register read --format int16_t[] edi
     edi = {-48 7103}
(lldb) register read --format int16_t[] esi
     esi = {34 7103}
(lldb) register read --format b rflags
  rflags = 0b0000000000000000000000000000000000000000000000000000001010010010</code></pre>
          <pre><code class="cpp">--------------- [XCode 6]
(lldb) register read --format int16_t[] di
      di = {-48}
(lldb) register read --format int16_t[] si
      si = {34}
(lldb) register read --format int16_t[] edi
     edi = {-48 0}
(lldb) register read --format int16_t[] esi
     esi = {34 0}
(lldb) register read --format b rflags
  rflags = 0b0000000000000000000000000000000000000000000000000000001000010010
                                                                     ^
                                                             Sign flag different</code></pre>
          <pre><code class="cpp">--------------- [XCode 6, with C code calling max]
(lldb) register read --format int16_t[] di
      di = {-48}
(lldb) register read --format int16_t[] si
      si = {34}
(lldb) register read --format int16_t[] edi
     edi = {-48 -1}
                 ^
         In the LLVM call, this is zero
(lldb) register read --format int16_t[] esi
     esi = {34 0}</code></pre>
          <p>
            In conclusion, this is a Clang/LLVM version mismatch. It's compiling muIntScalarMax_sint16 to emit a compl instead of a compw. The fact that the bug only reproduces with LLVM is because: LLVM doesn't set up the extended form of the register correctly for negative numbers, when calling a function with a word-sized register.
          </p>
          <p>
            The SysV ABI does not guarantee that the i16 will be sext'ed to i32. Clang ABI is probably an enhancement over the SysV ABI, and LLVM 3.5 doesn't know about this.
          </p>
        </article>
      </main>
    </div>
  </body>
</html>