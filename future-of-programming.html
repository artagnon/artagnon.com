<!DOCTYPE html>
<html>
  <head>
    <title>artagnon.com: future-of-programming</title>
    <meta charset="UTF-8" />
    <meta name="description" content="Ramkumar Ramachandra's site" />
    <meta name="author" content="Ramkumar Ramachandra" />
    <meta name="keywords" content="programming, linux, philosophy, git" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="/design/screen.css" media="screen" />
    <link rel="stylesheet" href="/design/claytext.css" media="screen" />
    <link rel="stylesheet" href="/design/mobile.css" media="only screen and (min-device-width: 320px) and (max-device-width: 600px)" />
    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans" />
    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono" />
    <link rel="shortcut icon" href="/design/favicon.ico" />
    <script type="text/javascript" src="/design/analyticstracking.js"></script>
  </head>
  <body>
    <div id="wrapper">
      <div id="main">
        <h1>On the future of programming</h1>
        <p>The art of programming is evolving steadily; more powerful hardware
          becomes available, and compiler technology evolves.  Ofcourse there
          will be resistance to change, and new compilers don&#39;t mature
          overnight. At the end of the day, it boils down to what can be parsed
          unambiguously, written down easily by human beings, and executed
          quickly. If you get off on reading research papers on dependent types
          and writing Agda programs to store in your attic, that&#39;s your choice;
          the rest of us will be happily writing Linux in C99 and powering the
          world.</p>
        <p>Programming has not fundamentally changed in any way. x86 is the clear
          winner as far as big hardware is concerned (ARM wins on embedded
          devices), and serious infrastructure is all written in C and
          C++. There is a significant risk to adopting any new language; the
          syntax might look pretty, but you figure out that the compiler team
          consists of incompetent monkeys writing leaking garbage collectors. We
          are pushing the boundaries everyday:</p>
        <ul class="ulitem">
          <li>Linux has never been better: it continues improve steadily (oh, and
            at what pace!). New filesystems optimized for SSDs, real
            virtualization using KVM, an amazing scheduler, and a new system
            calls. All software is limited by how well the kernel can run it.</li>
        </ul>
        <ul class="ulitem">
          <li>We&#39;re in the golden age of concurrency. Various runtimes are trying
            various techniques: erlang uses a message-passing actor hammer,
            async is a bit of an afterthought in C#, Node.js tries to do evented
            IO on top of V8, Haskell pushes forward with a theoretically-sound
            STM, and new languages like Go implement it deep at the
            scheduler-level.</li>
        </ul>
        <ul class="ulitem">
          <li>For a vast majority of applications, it&#39;s very clear that automatic
            memory management is a good trade-off. We&#39;re look down upon hideous
            nonsense like the reference-counter in cpython, and strive to write
            concurrent moving GCs. While JRuby has the advantage of
            piggy-banking on a mature runtime, the MRI community is taking GC
            very seriously. V8 apparently has a very sophisticated GC as well,
            otherwise Javascript wouldn&#39;t be performant.</li>
        </ul>
        <ul class="ulitem">
          <li>As far as typing is concerned, Ruby has definitely pushed the
            boundaries of dynamic programming. Javascript is another language
            with very loosely defined semantics, that many people are fond
            of. As far as typed languages go, there are only hideous languages
            like Java and C#. Go seems to have a nice flavor of type inference
            to it, but only time will tell if it&#39;ll be a successful model. Types
            make for faster code, because your compiler has to spend that much
            less time inspecting your object: V8 does a lot of type inference
            behind the scenes too.</li>
        </ul>
        <ul class="ulitem">
          <li>As far as extensibility is concerned, it&#39;s obvious that nothing can
            beat a syntax-less language (aka. Lisp). However, Lisps have
            historically suffered from a lack of typesystem and object system:
            CLOS is a disaster, and Typed Racket seems to be going
            nowhere. Clojure tries to bring some modern flavors into this
            paradigm (core.async et al), while piggy-banking on the JVM. Not
            sure where it&#39;s going though.</li>
        </ul>
        <ul class="ulitem">
          <li>As far as object systems go, nothing beats Java. It&#39;s a great way to
            fit together many shoddily-written components safely, and Dalvik
            does exactly that. You don&#39;t need a package-manager, and
            applications have very little scope for misbehaving because of the
            suffocating typesystem. Sure, it might not be be pleasant to write
            Java code, but we really have no other way of fitting so many tiny
            pieces together. It&#39;s used in enterprise for much the same reasons:
            it&#39;s too expensive to discipline programmers to write good code, so
            just constrain them with a really tight object system/typesystem.</li>
        </ul>
        <ul class="ulitem">
          <li>As far as functional programming goes, it&#39;s fair to say that all
            languages have incorporated some amount of it: Ruby differentiates
            between gsub and gsub! for instance. Being purely functional is a
            cute theoretical exercise, as the ugly scarab beetle on the Real
            World Haskell book so aptly indicates.</li>
        </ul>
        <ul class="ulitem">
          <li>As far as manual memory management goes (when you need kernels and
            web browsers), there&#39;s C and there&#39;s C++. Rust introduces some
            interesting pointer semantics, but it doesn&#39;t look like the project
            will last very long.</li>
        </ul>
        <p>Well, that ends my rant: I&#39;ve hopefully provided some food for
          thought.
          </p>
      </div>
      <div id="sidebar">
        <ul>
          <li>
            <a href="/index">index</a>
          </li>
          <li>
            <a href="/log">log</a>
          </li>
          <li>
            <a href="/colophon">colophon</a>
          </li>
        </ul>
      </div>
    </div>
  </body>
</html>