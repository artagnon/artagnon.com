<!DOCTYPE html>
<html>
  <head>
    <title>Homotopy Type Theory | artagnon.com</title>
    <meta charset="utf-8" />
    <meta name="language" content="english" />
    <meta name="author" content="Ramkumar Ramachandra" />
    <meta name="city" content="Paris" />
    <meta name="country" content="France" />
    <meta name="keywords" content="mathematics, mathematical notes, study notes, programming, blog, personal website" />
    <meta name="HandheldFriendly" content="true" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index,follow" />
    <link rel="stylesheet" href="/dist/style.min.css" />
    <script src="//ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
    <script>
      WebFont.load({
        google: {
          families: ['Josefin Sans', 'Roboto Mono']
        }
      });
    </script>
    <link rel="icon" href="/dist/favicon.ico" />
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-5837870-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async="" src="//www.google-analytics.com/analytics.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/cash/6.0.1/cash.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      extensions: ["tex2jax.js"], jax: ["input/TeX","output/HTML-CSS"],
      "HTML-CSS": { styles: {".MathJax_Preview": {visibility: "hidden"}} },
      tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]},
      TeX: {extensions: ["/dist/xypic.min.js","AMSmath.js","AMSsymbols.js"]} });
    </script>
    <link rel="preload" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/solarized-light.min.css" as="style" onload="this.onload=null;this.rel=&#39;stylesheet&#39;" />
    <noscript>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/solarized-light.min.css" />
    </noscript>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/coq.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script defer="" src="/dist/script.min.js"></script>
  </head>
  <body>
    <div id="wrapper">
      <main tabindex="0">
        <header>
          <h1>
            Homotopy Type Theory
          </h1>
          <div id="metadata">
            <span id="timestamp"><time datetime="2020-05-27" class="begin">Wed, 27 May 2020 12:24:05 +0200</time><span class="to">↪</span><time datetime="2020-05-27" class="end">Wed, 27 May 2020 20:26:33 +0200</time></span><br /><span id="locations"><address>Paris</address></span><span id="audience">Niche</span>
          </div>
        </header>
        <article>
          <p class="blurb">
            This is a brief exposé, which serves as an introduction to homotopy type theory
          </p>
          <p>
            To specify a new type in HoTT, we need to specify four different rules: formation, introduction, elimintion, computation (FIEC).
          </p>
          <ol class="olitems" type="i" start="1">
            <li>
              How to form a new type of this kind. For example $\Pi_{(x : A)} B(x)$
            </li>
            <li>
              How to construct elements of this kind. For example, a function type has one constructor: $f(x) :\equiv 2x$.
            </li>
            <li>
              How to use elements of this type. These are called eliminators or `elimination rules`. For instance, a function type has one eliminator, namely function application.
            </li>
            <li>
              How the eliminator acts on the constructor. For example, $(\lambda x . \phi)(a)$ is judgementally equal to the expanded function $\lambda f . f(x)$.
            </li>
            <li>
              An optional uniqueness principle which expresses uniqueness into or out of the type. Every element of the type is uniquely determined by results of applying type eliminators to it. It is often a provable propositional equality: in this case, we call it `propositional uniqueness principle`.
            </li>
          </ol>
          <p>
            Broadly speaking, there are two kinds of types: $\Pi$ (which turns out to be a degenerate case of an inductive type) and $\Sigma$.
          </p>
          <h2 id="the-dependent-product-type-pi-type">
            The dependent product type ($\Pi$-type)
          </h2>
          <p>
            Instead of defining projections $pr1$ and $pr2$ for the two projections from the pair, we will define a "recursor" as follows:
          </p>
          <p class="mathjax">
            $$
            rec_{A \times B} : \Pi_{C : U} (A \times B \times C) \rightarrow A \times B \rightarrow C \\
              rec_{A \times B}(C, g, (a, b)) :\equiv g(a)(b)
            $$
          </p>
          <p>
            So that:
          </p>
          <p class="mathjax">
            $$
            pr1 :\equiv rec_{A \times B}(A, \lambda a . \lambda b . a) \\
              pr2 :\equiv rec_{A \times B}(B, \lambda a . \lambda b . b)
            $$
          </p>
          <p>
            In order to be able to write dependent functions over the product type, we can define function $f : \Pi_{x : A \times B} C(x)$ by providing $g : \Pi_{x : A} \Pi_{x : B} C((x, y))$ with the defining equation $f((x, y)) = g(x)(y)$.
          </p>
          <p>
            To prove a property for all elements of a prduct, it is enough to prove it for its canonical elements (the ordered pairs). In the universal case, we call the resulting function induction for product types:
          </p>
          <p class="mathjax">
            $$
            ind_{A \times B} : \Pi_{C : A \times B \rightarrow U} (\Pi_{x : A}\Pi_{y : B} C((x, y))) \rightarrow \Pi_{x : A \rightarrow B} C(x)
            $$
          </p>
          <p>
            with the defining equation:
          </p>
          <p class="mathjax">
            $$
            ind_{A \times B}(C, g, (a, b)) :\equiv g(a)(b)
            $$
          </p>
          <p>
            Because induction describes how to use an element of the product type, induction is often called the `dependent eliminator` and recursion is called the `non-dependent eliminator`.
          </p>
          <h2 id="the-dependent-pair-type-sigma-type">
            The dependent pair type ($\Sigma$-type)
          </h2>
          <p>
            The dependent pair type is written $\Sigma_{x : A}, B(x)$. When the second component doesn't depend on the first, we get the cartesian product type $A \times B$. The first projection follows a straightforward extraction:
          </p>
          <p class="mathjax">
            $$
            pr1 : (\Sigma_{x : A} B(x)) \rightarrow A
            $$
          </p>
          <p>
            However, the second projection must be a dependent function, whose type involves the first projection function:
          </p>
          <p class="mathjax">
            $$
            pr2 : \Pi_{p: \Sigma_{x : A} B(x)} B(pr1(p))
            $$
          </p>
          <p>
            Thus, we need the induction principle for $\Sigma$-types (the `dependent eliminator`):
          </p>
          <p class="mathjax">
            $$
            g : \Pi_{a : A}\Pi_{b : B(a)} C((a, b))
            $$
          </p>
          <p>
            We can then derive a function:
          </p>
          <p class="mathjax">
            $$
            f : \Pi_{p:\Sigma_{x : A}, B(x)} C(p)
            $$
          </p>
          <p>
            In order to package up the recursion and induction principles into a recursor for $\Sigma$, which we will not bother elaborating here. Instead, let's provide an example of the magma type, in which the second component depends on the first component:
          </p>
          <p class="mathjax">
            $$
            Magma :\equiv \Sigma_{A : U} A \rightarrow A \rightarrow A
            $$
          </p>
          <h2 id="mathbb-n-and-primitive-recursion">
            $\mathbb{N}$ and primitive recursion
          </h2>
          <p>
            To define infinite types like $\mathbb{N}$, we need the additional concept of well-founded recursion. We can package the recursor into a single function, as previously:
          </p>
          <p class="mathjax">
            $$
            rec_\mathbb{N} : \Pi_{C : U} C \rightarrow (\mathbb{N} \rightarrow C \rightarrow C) \rightarrow \mathbb{N} \rightarrow C
            $$
          </p>
          <p>
            Given step 0, and a next-step function, we can define:
          </p>
          <p class="mathjax">
            $$
            rec_{\mathbb{N}}(C, c_0, c_s, 0) = c_0 \\
              rec_{\mathbb{N}}(C, c_0, c_s, succ(n)) = c_s(n, rec_\mathbb{N}(C, c_0, c_s, n))
            $$
          </p>
          <p>
            We can generalize general recursion to dependent functions as follows:
          </p>
          <p class="mathjax">
            $$
            ind_{\mathbb{N}} : \Pi_{C : \mathbb{N} \rightarrow U} C(0) \rightarrow (\Pi_{n : \mathbb{N}} C(n) \rightarrow C(succ(n))) \rightarrow \Pi_{n \in \mathbb{N}} C(n)
            $$
          </p>
          <p>
            with these defining equations:
          </p>
          <p class="mathjax">
            $$
            f(0) :\equiv c_0 \\
              f(succ(n)) :\equiv c_s(n, f(n))
            $$
          </p>
        </article>
      </main>
      <nav>
        <ul>
          <li>
            <a href="/index">index</a>
          </li>
          <li>
            <a href="/ag">ag</a>
          </li>
          <li>
            <a href="/algebra">algebra</a>
          </li>
          <li>
            <a href="/attic">attic</a>
          </li>
          <li>
            <a href="/category">category</a>
          </li>
          <li>
            <a href="/notes">notes</a>
          </li>
          <li>
            <a href="/topoi">topoi</a>
          </li>
          <li>
            <a href="/topology">topology</a>
          </li>
          <li>
            <a href="/zfc">zfc</a>
          </li>
        </ul>
      </nav>
    </div>
  </body>
</html>