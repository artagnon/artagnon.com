<!DOCTYPE html>
<html>
  <head>
    <title>Homotopy Type Theory | artagnon.com</title>
    <meta charset="utf-8" />
    <meta name="language" content="english" />
    <meta name="author" content="Ramkumar Ramachandra" />
    <meta name="city" content="Paris" />
    <meta name="country" content="France" />
    <meta name="keywords" content="mathematics, mathematical notes, study notes, programming, blog, personal website" />
    <meta name="HandheldFriendly" content="true" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index,follow" />
    <link rel="stylesheet" href="/dist/style.min.css" />
    <script src="//ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
    <script>
      WebFont.load({
        google: {
          families: ['Josefin Sans', 'Roboto Mono']
        }
      });
    </script>
    <link rel="icon" href="/dist/favicon.ico" />
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-5837870-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async="" src="//www.google-analytics.com/analytics.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/cash/6.0.1/cash.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      extensions: ["tex2jax.js"], jax: ["input/TeX","output/HTML-CSS"],
      "HTML-CSS": { styles: {".MathJax_Preview": {visibility: "hidden"}} },
      tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]},
      TeX: {extensions: ["/dist/xypic.min.js","AMSmath.js","AMSsymbols.js"]} });
    </script>
    <link rel="preload" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/solarized-light.min.css" as="style" onload="this.onload=null;this.rel=&#39;stylesheet&#39;" />
    <noscript>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/solarized-light.min.css" />
    </noscript>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/coq.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script defer="" src="/dist/script.min.js"></script>
  </head>
  <body>
    <div id="wrapper">
      <main tabindex="0">
        <header>
          <h1>
            Homotopy Type Theory
          </h1>
          <div id="metadata">
            <span id="timestamp"><time datetime="2020-05-27" class="begin">Wed, 27 May 2020 12:24:05 +0200</time><span class="to">↪</span><time datetime="2020-05-27" class="end">Wed, 27 May 2020 18:38:38 +0200</time></span><br /><span id="locations"><address>Paris</address></span><span id="audience">Niche</span>
          </div>
        </header>
        <article>
          <p class="blurb">
            This is a brief exposé, which serves as an introduction to homotopy type theory
          </p>
          <p>
            To specify a new type in HoTT, we need to specify four different rules: formation, introduction, elimintion, computation (FIEC).
          </p>
          <ol class="olitems" type="i" start="1">
            <li>
              How to form a new type of this kind. For example $\Pi_{(x : A)} B(x)$
            </li>
            <li>
              How to construct elements of this kind. For example, a function type has one constructor: $f(x) :\equiv 2x$.
            </li>
            <li>
              How to use elements of this type. These are called eliminators or `elimination rules`. For instance, a function type has one eliminator, namely function application.
            </li>
            <li>
              How the eliminator acts on the constructor. For example, $(\lambda x . \phi)(a)$ is judgementally equal to the expanded function $\lambda f . f(x)$.
            </li>
            <li>
              An optional uniqueness principle which expresses uniqueness into or out of the type. Every element of the type is uniquely determined by results of applying type eliminators to it. It is often a provable propositional equality: in this case, we call it `propositional uniqueness principle`.
            </li>
          </ol>
          <p>
            Broadly speaking, there are two kinds of types: $\Pi$ (which turns out to be a degenerate case of an inductive type) and $\Sigma$.
          </p>
          <h2 id="the-dependent-product-type-pi-type">
            The dependent product type ($\Pi$ type)
          </h2>
          <p>
            Instead of defining projections $pr1$ and $pr2$ for the two projections from the pair, we will define a "recursor" as follows:
          </p>
          <p class="mathjax">
            $$
            rec_{A \times B} : \Pi_{C : U} (A \times B \times C) \rightarrow A \times B \rightarrow C \\
              rec_{A \times B}(C, g, (a, b)) :\equiv g(a)(b)
            $$
          </p>
          <p>
            So that:
          </p>
          <p class="mathjax">
            $$
            pr1 :\equiv rec_{A \times B}(A, \lambda a . \lambda b . a) \\
              pr2 :\equiv rec_{A \times B}(B, \lambda a . \lambda b . b)
            $$
          </p>
          <p>
            In order to be able to write dependent functions over the product type, we can define function $f : \Pi_{x : A \times B} C(x)$ by providing $g : \Pi_{x : A} \Pi_{x : B} C((x, y))$ with the defining equation $f((x, y)) = g(x)(y)$.
          </p>
          <p>
            To prove a property for all elements of a prduct, it is enough to prove it for its canonical elements (the ordered pairs). In the universal case, we call the resulting function induction for product types:
          </p>
          <p class="mathjax">
            $$
            ind_{A \times B} : \Pi_{C : A \times B \rightarrow U} (\Pi_{x : A}\Pi_{y : B} C((x, y))) \rightarrow \Pi_{x : A \rightarrow B} C(x)
            $$
          </p>
          <p>
            with the defining equation:
          </p>
          <p class="mathjax">
            $$
            ind_{A \times B}(C, g, (a, b)) :\equiv g(a)(b)
            $$
          </p>
          <h2 id="the-dependent-sum-type-sigma-type">
            The dependent sum type ($\Sigma$ type)
          </h2>
        </article>
      </main>
      <nav>
        <ul>
          <li>
            <a href="/index">index</a>
          </li>
          <li>
            <a href="/ag">ag</a>
          </li>
          <li>
            <a href="/algebra">algebra</a>
          </li>
          <li>
            <a href="/attic">attic</a>
          </li>
          <li>
            <a href="/category">category</a>
          </li>
          <li>
            <a href="/notes">notes</a>
          </li>
          <li>
            <a href="/topoi">topoi</a>
          </li>
          <li>
            <a href="/topology">topology</a>
          </li>
          <li>
            <a href="/zfc">zfc</a>
          </li>
        </ul>
      </nav>
    </div>
  </body>
</html>