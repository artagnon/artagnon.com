Homotopy Type Theory: The essentials

...
Here, we discuss concepts from Ch.2 of the HoTT book
...

The central idea is that types can be interpreted as higher-dimensional groupoids in category theory, or spaces in homotopy theory. Space $X$ is a set of points equipped with a topology, and a path betwen points $x$ and $y$ is represented by a continuous map $p : [0, 1] \rightarrow X$ where $p(0) = x, p(1) = y$. The function can be thought of as giving a point $x$ at each moment in time. A `homotopy` between a pair of continuous maps $H : X_1 \times [0, 1] \rightarrow X_2$, so that $H(s, 0) = p(s)$ and $H(s, 1) = q(s)$, can be thought of as a continuous deformation from $p$ to $q$.

The `fundamental group` of a fundamental $\infty$-groupoid of a space will agree with the classical definition of a fundamental group of the space: this correspondence illustrates how homotopy theory and higher-dimensional category theory are intimately related.

We will refer to $x =_A y$ as a path between the `start point` $x$ and `endpoint` $y$. $r : p =_{x =_A y} q$ can be thought of as a homotopy or a 2-path or 2-dimensional path. All of the basic constructions and axoims arises automatically from the induction principle for identity types. In other words, given the dependent funtions:

(i) $D : \Pi_{x, y : A} (x = y) \rightarrow \mathscr{U}$
(ii) $d : \Pi_{a : A} D(a, a, \texttt{refl}_a)$

there is a dependent function:

$$
  ind_{=A}(D, d) : \Pi_{x, y : A} \Pi_{p : x = y} D(x, y, p)
$$

such that

$$
  ind_{=A}(D, d, a, a, \texttt{refl}_a) \equiv d(a)
$$

Informally, the induction principle for identity types says that if we want to construct an object which depends on an inhabitant $p : x =_A y$ of an identity type, then it suffices to perform the construction in the special case when $x, y$ are judgementally the same, and $p$ is the reflexivity element $\texttt{refl}_x x = x$.

The induction principle endows each type with the structure of an $\infty$-groupoid, and each function between two types with the structure of the an $\infty$-functor betwen two such groupoids.

# Types are higher groupoids

+ To state our first lemma:

$$
  \Pi_{A : \mathscr{U}} \Pi_{x, y : A} (x = y) \rightarrow (y = x)
$$

The proof of this lemma would involve constructing an inhabitant of this type. Let us write the proof in an informal style, as this is preferred. We want to construct $x, y :A$, $p : x = y$, and $p^{-1} : y = x$. By induction, it suffices to consider the case when $y = x$ and $p = \texttt{refl}_x$. In this case, the type of $x = y$ and $y = x$, in which we're trying to construct $p^{-1}$, are both equal to $x = x$. Thus, in the reflexivity case, we can define $\texttt{refl}_x^{-1}$ to simply be $\texttt{refl}_x$. The general case therefore proceeds by the induction principle, and the conversion rule $\texttt{refl}_x^{-1} \equiv \texttt{refl}_x$.

+ To state our second lemma:

$$
  \Pi_{A : \mathscr{U}} \Pi_{x, y, z : A} (x = y) \rightarrow (y = z) \rightarrow (x = z)
$$

The proof proceeds as follows: $\forall x, y, z : A$, every $p : x = y$ and every $q : y = z$, we need to construct an inhabitant of $x = z$. By induction on $p$, it sufficces to assume that $y = x$ and $p$ is $\texttt{refl}_x$. In this case, the type of $y = z$ of $q$ is $x = z$. By induction on $q$, it suffices to assume that $z = x$ and $q$ is $\texttt{refl}_x$. In this case, $x = z$ is $x = x$, and we have $\texttt{refl}_x : (x = x)$.

This proof raises the question of why an induction on $q$ is required at all, when we already have the equality $x = z$. Indeed, we could have done an induction on $p$ yielding the computation rule $p \circ \texttt{refl}_x \equiv p$, an induction on $q$ yielding the computation rule $\texttt{refl}_y \circ q \equiv q$, or, as above, induction on both $p$ and $q$, yeilding $\texttt{refl}_x \circ \texttt{refl}_x \equiv \texttt{refl}_x$. We would merely have three different elements of the same type.

+ We will now state some results without the obvious proofs. For $\Pi_{A : \mathscr{U}} \Pi_{x, y, z, w : A}$, $p : x = y$, $q : y = z$, $r : z = w$:

(i) $p = p \circ \texttt{refl}_y$ and $p = \texttt{refl}_x \circ p$
(ii) $p^{-1} \circ p = \texttt{refl}_y$ and $p \circ p^{-1} = \texttt{refl}_x$
(iii) $(p^{-1})^{-1} = p$
(iv) $(p \circ q) \circ r = p \circ (q \circ r)$

Given a type $A$ with point $a : A$, we define its loop space $\Omega(A, a)$ to be the type $a =_A a$; we could concatenate this to $\Omega A$ if $a$ is understood from the context. Since any two elements of $\Omega A$ are paths with the same start and endpoints, we have $\Omega A \times \Omega A \rightarrow \Omega A$. It can also be fruitful to consider the loop space of a loop space of $A$, the space of 2-dimensional loops, written $\Omega^2(A, a)$, represented as $\texttt{refl}_a =_{a =_A a} \texttt{refl}_a$.

+ The Eckmann-Hilton theorem can be stated as $\Omega^2(A) \times \Omega^2(A) \rightarrow \Omega^2(A)$ being commutative: $\alpha \circ \beta = \beta \circ \alpha$ for any $\alpha, \beta : \Omega^2(A)$.

First, notice that $\Omega A \times \Omega A \rightarrow \Omega A$ induces an operation:

$$
  \star : \Omega^2(A) \times \Omega^2(A) \rightarrow \Omega^2(A)
$$

In the following diagram,
$$
  \begin{matrix}
    p : a = b & q : a = b \\
    r : b = c & s : b = c \\
    \alpha : p = q & \beta : r = s
  \end{matrix}
$$

{{
  & \ar@{=>}[dd]_\alpha && \ar@{=>}[dd]_\beta & \\
  a \ar@/^3pc/[rr]^p\ar@/_3pc/[rr]_q && b \ar@/^3pc/[rr]^r\ar@/_3pc/[rr]_s && c \\
  & & & &
}}

Composing the two upper and lower paths, we get $p \circ r, q \circ s : a = c$. The horizontal composition can be written as $\alpha \star \beta : p \circ r = q \circ s$ defined as follows. First, we define $\alpha \circ_r r = p \circ_r = q \circ r$ by path induction on $r$ so that

$$
  \alpha \circ_r \texttt{refl}_b \equiv \texttt{ru}_p^{-1} \circ \alpha \circ \texttt{ru}_q
$$

where $\texttt{ru}_p = p \circ \texttt{refl}_b$ is the right unit lemma, which we previously mentioned. We can also define $q \circ_l \beta : q \circ r = q \circ s$ by induction on $q$ so that

$$
  \texttt{refl}_b \circ_l \beta \equiv \texttt{lu}_r^{-1} \circ \beta \circ \texttt{lu}_s
$$

where $\texttt{lu}_r$ denotes the left unit law. The operations $\circ_l$ and $\circ_r$ are called `whiskering`. In the HoTT codebase, this is written as:

~~
Definition whiskerL {A : Type} {x y z : A} (p : x = y)
  {q r : y = z} (h : q = r) : p @ q = p @ r
:= 1 @@ h.

Definition whiskerR {A : Type} {x y z : A} {p q : x = y}
  (h : p = q) (r : y = z) : p @ r = q @ r
:= h @@ 1.
~~

Next, since $\alpha \circ_r r$ and $q \circ_l \beta$ are composable 2-paths, we can define horizontal composition by:

$$
  \alpha \star \beta :\equiv (\alpha \circ_r r)(q \circ_l \beta)
$$

Now, suppose that $a \equiv b \equiv c$ so that all paths $p, q, r, s$ are elements of $\Omega(A, a)$, and assume moreover that $p \equiv q \equiv r \equiv s \equiv \texttt{refl}_a$, so that $\alpha : \texttt{refl}_a = \texttt{refl}_a$ and $\beta : \texttt{refl}_a = \texttt{refl}_a$ are composable in both orders. In this case, we have:

$$
  \alpha \star \beta = \alpha \circ \beta = \alpha \star' \beta = \beta \circ \alpha
$$

The foregoing fact, known as the `Eckmann-Hilton argument` comes from classical homotopy theory and is used later to show that higher homotopy groups of a type are always abelian groups. In the HoTT codebase, this is defined as follows:

~~
Definition eckmann_hilton {A : Type} {x:A} (p q : 1 = 1 :> (x = x)) : p @ q = q @ p :=
  (whiskerR_p1 p @@ whiskerL_1p q)^
  @ (concat_p1 _ @@ concat_p1 _)
  @ (concat_1p _ @@ concat_1p _)
  @ (concat_whisker _ _ _ _ p q)
  @ (concat_1p _ @@ concat_1p _)^
  @ (concat_p1 _ @@ concat_p1 _)^
  @ (whiskerL_1p q @@ whiskerR_p1 p).
~~

A `pointed type` $(A, a)$ is a type $A : \mathscr{U}$ together with a point $a : A$ called its `basepoint`. We write $\mathscr{U}_\bullet :\equiv \Sigma_{A : \mathscr{U}}$ for the type of pointed types in universe $\mathscr{U}$.

Given a pointed type $(A, a)$, we can define the `loop space` of $(A, a)$ to be the following pointed type:

$$
  \Omega(A, a) :\equiv ((a =_A a), \texttt{refl}_a)
$$

An element of it will be called a `loop` at a. For $n : \mathbb{N}$, the `n-fold iterated loop space` $\Omega^n(A, a)$ of a pointed type $(A, a)$ is defined recursively by:

$$
  \Omega^0(A, a) :\equiv (A, a) \\
  \Omega^{n + 1}(A, a) :\equiv \Omega^n(\Omega(A, a))
$$

An element of it will be called an `n-loop` at $a$.

# Functions are functors

From a type theoretic perspective, functions should respect equality; topologically, this corresponds to saying that every function is continuous (or preserves paths).

+ Given function $f : A \rightarrow B$, then for $x, y : A$, there is an operation

$$
  \texttt{ap}_f : (x =_A y) \rightarrow (f(x) =_B f(y))
$$

$\texttt{ap}_f$ can be read as the application of a function to a path. To give a flavor of how $f(p)$ is defined in the HoTT codebase,

~~
Definition ap {A B : Type} (f : A -> B) {x y : A} (p : x = y) : f x = f y
  := match p with idpath => idpath end.
~~

To provide a simple proof, it suffices to assume that $p$ is $\texttt{refl}_x$. In this case, we may define $\texttt{ap}_f(p) :\equiv \texttt{refl}_{f(x)} f(x) = f(x)$. We will often write $\texttt{ap}_f(p)$ as $f(p)$, and this matches the common category theory convention of using the same symbol for application of a functor to objects and morphisms.

+ We will now provide some facts about $\texttt{ap}_f$ without proof.

(i) $\texttt{ap}_f(p \circ q) = \texttt{ap}_f(p) \circ \texttt{ap}_f(q)$
(ii) $\texttt{ap}_f(p^{-1}) = \texttt{ap}_f(p)^{-1}$
(iii) $\texttt{ap}_g(\texttt{ap}_f(p)) = \texttt{ap}_{g \circ f}(p)$
(iv) $\texttt{ap}_{\texttt{id}_A} = p$

These are themselves paths, which have to satisfy coherence laws, as usual.

# Type families are fibrations

If $\Pi_{x : A} B(x)$ and $p : x = y$, then $f(x) : B(x)$ and $f(y) : B(y)$ are elements of distinct types, so that a priori, we cannot even ask whether they are equal. The misssing ingridient is that $p$ itself gives us a way to relate $B(x)$ and $B(y)$. This problem was stated as `indiscrenability of identicals` in our [previous note](HoTT-foundations#identity-types).

+ `Transport lemma`. Suppose $P$ is a type family over $A$ and $p : x =_A y$, then there is a function $p_\star : P(x) \rightarrow P(y)$.

Let $D : \Pi_{x, y : A}(x = y) \rightarrow \mathscr{U}$ be the type family defined by:

$$
  D(x, y, p) :\equiv P(x) \rightarrow P(y)
$$

then we have the function

$$
  d :\equiv \lambda x . \texttt{id}_{P(x)} : \Pi_{x : A} D(x, x, \texttt{refl}_x)
$$

so that the induction principle gives us $\texttt{ind}_{=A}(D, d, x, y, p) : P(x) \rightarrow P(y)$.

Sometimes, it is notate the type family $P$ in which the transport operation happens:

$$
  \texttt{transport}^P(p, -) : P(x) \rightarrow P(y)
$$

Topologically, the transport lemma can be viewed as a "path lifting" operation on a fibration. We think of a type famiy $P : A \rightarrow \mathscr{U}$ as a fibration with base space $A$, with $P(x)$ being the fiber over $x$, and with $\Sigma_{x : A} P(x)$ being the `total space` of the fibration, with first projection $\Sigma_{x : A} P(x) \rightarrow A$.

The defining property of a fibration is that given a path $p : x = y$ in the base space $A$ and a point $u : P(x)$ in a fiber over $x$, we may lift we may lift the path $p$ to a total space starting at $u$, and this lifting can be done continuously. The point $p_\star(u)$ can be thought of as the other endpoint of this lifted path. In the HoTT codebase, this is written as:

~~
Definition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y :=
  match p with idpath => u end.
~~

+ We now state `path lifting property` without proof. Let $P : A \rightarrow \mathscr{U}$ be a type family over $A$, and assume we have $u : P(x)$ for some $x : A$. Then, for $p : x = y$, we have:

$$
  \texttt{lift}(u, p) : (x, y) = (y, p_\star(u))
$$

in $\Sigma_{x : A} P(x)$, such that $\texttt{pr}_1(\texttt{lift}(u, p)) = p$. To peek into the definition in the HoTT codebase:

~~
Definition equiv_path_sigma `(P : A -> Type) (u v : sigT P)
: {p : u.1 = v.1 &  p # u.2 = v.2} <~> (u = v)
  := Build_Equiv _ _ (path_sigma_uncurried P u v) _.
~~

In classical homotopy theory, a fibration is defined as a map for which there exist liftings of paths, while in contrast, we have shown that in type theory, every type family comes with a specified "lifting function".

When the type family $P : A \rightarrow \mathscr{U}$ is regarded as a fibration, the base is $A$, and the total space is $\Sigma_{x : A} P(x)$. We may also refer to the dependent function $\Pi_{x : A} P(x)$ as the `section` of the fibration $P$, and we may say that something happens `fiberwise` if it happens for each $P(x)$. For instance, a section $f : \Pi_{x : A} P(x)$ shows that $P$ is "fiberwise inhabited".

We can now prove a dependent version of the lemma $\texttt{ap}_f : (x =_A y) \rightarrow (f(x) =_B f(b))$ as follows. Given $\Pi_{x : A} P(x)$, we can define a non-dependent version of the function $f' : A \rightarrow \Sigma_{x : A} P(x)$ by setting $f'(x) :\equiv (x, f(x))$ and consider $f'(p) : f'(x) = f'(y)$. Since $\texttt{pr}_1 \circ f' \equiv \texttt{id}_A$, we have $\texttt{pr}_1(f'(p)) \equiv p$; thus $f'(p)$ does "lie over" $p$ in this sense. However, it is not obvious from the type of $f'(p)$ that it lies over any specific path in $A$ (in this case $p$), which is sometimes important.

The solution is to use the transport lemma; we have a canonical path $\texttt{lift}(u, p)$ from $(x, u)$ to $(u, p_\star(u))$, which lies over $p$. Thus, any path from $u : P(x)$ to $v : P(y)$ lying over $p$ should factor through $\texttt{lift}(u, p)$.

+ `Dependent map`. Suppose $f : \Pi_{x : A} P(x)$, we have a map

$$
  \texttt{apd}_f : \Pi_{p : x = y} p_\star(f(x)) =_{P(y)} f(y)
$$

Another peek into the HoTT codebase yields:

~~
(** Similarly, dependent functions act on paths; but the type is a bit more subtle.
If [f : forall a:A, B a] and [p : x = y] is a path in [A], then [apD f p] should somehow
be a path between [f x : B x] and [f y : B y]. Since these live in different types,
we use transport along [p] to make them comparable: [apD f p : p # f x = f y].

  The type [p # f x = f y] can profitably be considered as a heterogeneous or
  dependent equality type, of "paths from [f x] to [f y] over [p]". *)

Definition apD {A : Type} {B : A->Type} (f : forall a: A, B a) {x y : A} (p : x=y):
  p # (f x) = f y
  :=
  match p with idpath => idpath end.
~~

We prove it as follows. Let $D : \Pi_{x, y : A} (x = y) \rightarrow \mathscr{U}$ be the type family defined by

$$
  D(x, y, p) :\equiv p_\star(f(x)) = f(y)
$$

Then $D(x, x, \texttt{refl}_x)$ is ($\texttt{refl}_x)_\star = f(x)$. Then we get $D(x, x, \texttt{refl}_x) \equiv f(x) = f(x)$. Thus, we find the function:

$$
  d :\equiv \lambda x . \texttt{refl}_{f(x)} : \Pi_{x : A} D(x, x, \texttt{refl}_x)
$$

and now, path induction gives us $\texttt{apd}_f(p) : p_\star(f(x)) = f(y)$ for each $p : x = y$.

We will refer generally to paths which "lie over paths" in this sense as `dependent paths`. Since a non-dependently typed function is a special case of a dependently typed function, we have the following relation between $\texttt{apd}_f$ and $\texttt{ap}_f$:

+ If $P : A \rightarrow \mathscr{U}$ is defined by $P(x) :\equiv B$ for a fixed $B : \mathscr{U}$, then for any $x, y : A$, $p : x = y$, and $b : B$, we have a path:

$$
  \texttt{transportconst}^B_P(b) : \texttt{transport}^P(p, b) = b
$$

The corresponding Coq code looks like:

~~
(** Transporting in a constant fibration. *)
Definition transport_const {A B : Type} {x1 x2 : A} (p : x1 = x2) (y : B)
  : transport (fun x => B) p y = y.
Proof.
  destruct p. exact 1.
Defined.
~~

In English, it suffices to assume that $y$ is $x$, and $p$ is $\texttt{refl}_x$. But $\texttt{transport}^P(\texttt{refl}_x, b) \equiv b$, so in this case, we have to prove that $b = b$, which can be discharged by $\texttt{refl}_b$.

By concatenating $\texttt{transportconst}$ and its inverse, we obtain:

$$
  f(x) = f(y) \rightarrow p_\star(f(x)) = f(y) \\
  p_\star(f(x) = f(y)) \rightarrow f(x) = f(y)
$$

+ Let us now dump a few definitions and lemmas in Coq:

~~
(** In a constant fibration, [apD] reduces to [ap], modulo [transport_const]. *)
Lemma apD_const {A B} {x y : A} (f : A -> B) (p : x = y) :
  apD f p = transport_const p (f x) @ ap f p.
Proof.
  destruct p; reflexivity.
Defined.
~~

~~
(** Transporting in a pulled back fibration. *)
Lemma transport_compose {A B} {x y : A} (P : B -> Type) (f : A -> B)
  (p : x = y) (z : P (f x))
  : transport (fun x => P (f x)) p z  =  transport P (ap f p) z.
Proof.
  destruct p; reflexivity.
Defined.
~~

~~
Lemma ap_transport {A} {P Q : A -> Type} {x y : A} (p : x = y) (f : forall x, P x -> Q x) (z : P x) :
  f y (p # z) = (p # (f x z)).
Proof.
  by induction p.
Defined.
~~

~~
Definition transport_pp {A : Type} (P : A -> Type) {x y z : A} (p : x = y) (q : y = z) (u : P x) :
  p @ q # u = q # p # u :=
  match q with idpath =>
    match p with idpath => 1 end
  end.
~~

# Homotopies and equivalences

It is now time to talk about identifications between types and functions. For two functions to be equal, they must agree on every element in their domains. Let $f, g : \Pi_{x : A} P(x)$ be two sections of of the type family $P : A \rightarrow \mathscr{U}$. A homotopy from $f$ to $g$ is the dependent function:

$$
  f \sim g :\equiv \Pi_{x : A} f(x) = g(x)
$$

Note that this is not the same thing as $f = g$, but we will revisit this when we talk about the univalence axiom.

Just as functions in type theory are automatically functors, homotopies are automatically natural transforms:

$$
  \Pi_{f : \Pi_{x : A} P(x)} (f \sim f) \\
  \Pi_{f, g : \Pi_{x : A} P(x)} (f \sim g) \rightarrow (g \sim f) \\
  \Pi_{f, g, h : \Pi_{x : A} P(x)} (f \sim g) \rightarrow (g \sim h) \rightarrow (f \sim h)
$$

+ Suppose $H : f \sim g$ is a homotopy between functions $f, g : A \rightarrow B$ and let $p : x =_A y$. Then we have:

$$
  H(x) \circ g(p) = f(p) \circ H(y)
$$

We may also draw the commutative diagram:

{{
  f(x)\ar@{=}[r]^{f(p)}\ar@{=}[d]_{H(x)} & f(y)\ar@{=}[d]^{H(y)} \\
  g(x)\ar@{=}[r]_{g(p)} & g(y)
}}
