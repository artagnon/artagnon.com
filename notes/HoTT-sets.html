<!DOCTYPE html>
<html>
  <head>
    <title>Homotopy Type Theory: Sets and Logic | artagnon.com</title>
    <meta charset="utf-8" />
    <meta name="language" content="english" />
    <meta name="author" content="Ramkumar Ramachandra" />
    <meta name="city" content="Paris" />
    <meta name="country" content="France" />
    <meta name="keywords" content="mathematics, mathematical notes, study notes, programming, blog, personal website" />
    <meta name="HandheldFriendly" content="true" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index,follow" />
    <link rel="stylesheet" href="/dist/style.min.css" />
    <script src="//ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
    <script>
      WebFont.load({
        google: {
          families: ['Josefin Sans', 'Roboto Mono']
        }
      });
    </script>
    <link rel="icon" href="/dist/favicon.ico" />
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-5837870-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async="" src="//www.google-analytics.com/analytics.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/cash/6.0.1/cash.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      extensions: ["tex2jax.js"], jax: ["input/TeX","output/HTML-CSS"],
      "HTML-CSS": { styles: {".MathJax_Preview": {visibility: "hidden"}} },
      tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]},
      TeX: {extensions: ["/dist/xypic.min.js","AMSmath.js","AMSsymbols.js"]} });
    </script>
    <link rel="preload" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/solarized-light.min.css" as="style" onload="this.onload=null;this.rel=&#39;stylesheet&#39;" />
    <noscript>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/solarized-light.min.css" />
    </noscript>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/coq.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script defer="" src="/dist/script.min.js"></script>
  </head>
  <body>
    <div id="wrapper">
      <main tabindex="0">
        <header>
          <h1>
            Homotopy Type Theory: Sets and Logic
          </h1>
          <div id="metadata">
            <span id="timestamp"><time datetime="2020-06-06" class="begin">Sat, 06 Jun 2020 09:56:04 +0200</time><span class="to">â†ª</span><time datetime="2020-06-08" class="end">Mon, 08 Jun 2020 15:41:36 +0200</time></span><br /><span id="locations"><address>Paris</address></span>
          </div>
        </header>
        <article>
          <p class="blurb">
            This note corresponds to Ch. 3 in the HoTT book
          </p>
          <p>
            This chapter is dedicated to the study of `HSet` (sets, the $0$-type), `HProp` (mere propositions, the $(-1)$-type), and `Contr` (contractible types, the $(-2)$-type):
          </p>
          <pre><code class="language-coq">Notation Contr := (IsTrunc minus_two).
Notation IsHProp := (IsTrunc minus_two.+1).
Notation IsHSet := (IsTrunc minus_two.+2).</code></pre>
          <p>
            focusing on the logic of mere propositions and the notion of `propositional truncation`.
          </p>
          <h2 id="sets-and-n-types">
            Sets and $n$-types
          </h2>
          <p>
            A type $A$ is a `set` if forall $x, y : A$ and $p, q : x = y$, we have $p = q$. The proposition $\texttt{isSet}(A)$ is defined to be the type:
          </p>
          <p class="mathjax">
            $$
            \texttt{isSet}(A) = \Pi_{x, y : A} \Pi_{p, q : x = y} (p = q)
            $$
          </p>
          <p>
            Sets in homotopy type theory are not like sets in ZF set theory, in that there is no global "membership predicate" $\in$. To provide some examples of sets, $\mathbb{1}$, $\mathbb{0}$ and $\mathbb{N}$ are sets.
          </p>
          <pre><code class="language-coq">Global Instance hprop_Empty : IsHProp Empty.
Proof. intro x. destruct x. Defined.</code></pre>
          <pre><code class="language-coq">Corollary hset_nat : IsHSet nat.
Proof.
  exact _.
Defined.</code></pre>
          <p>
            Moreover, if $A$ and $B$ are sets, then so is $A \times B$. For given $x, y : A \times B$ and $p, q : x = y$, we have $p = \texttt{pair}^=(\texttt{ap}_{\texttt{pr}_1}(p), \texttt{ap}_{\texttt{pr}_2}(p))$ and $q = \texttt{pair}^=(\texttt{ap}_{\texttt{pr}_1}(q), \texttt{ap}_{\texttt{pr}_2}(q))$. But $\texttt{ap}_{\texttt{pr}_1}(p) = \texttt{ap}_{\texttt{pr}_1}(q)$ since $A$ is a set, and $\texttt{ap}_{\texttt{pr}_2}(p) = \texttt{ap}_{\texttt{pr}_2}(q)$, since $B$ is a set; hence $p = q$.
          </p>
          <p>
            Similarly, if $A$ is a set, and $B : A \rightarrow \mathscr{U}$ such that $B(x)$ is a set, then $\Sigma_{x : A} B(x)$ is a set
          </p>
          <p>
            Given $B : A \rightarrow \mathscr{U}$, $\Pi_{x : A} B(x)$ is a set. For suppose $f, g : \Pi_{x : A} B(x)$ and for $p, q : f = g$. By functional extensionality,
          </p>
          <p class="mathjax">
            $$
            p = \texttt{funext}(x \mapsto \texttt{happly}(p, x)) \quad q = \texttt{funext}(x \mapsto \texttt{happly}(q, x))
            $$
          </p>
          <p>
            But for $x : A$, we have
          </p>
          <p class="mathjax">
            $$
            \texttt{happly}(p, x) : f(x) = g(x) \quad \texttt{happly}(q, x) : f(x) = g(x)
            $$
          </p>
          <p>
            So since $B(x)$ is a set, we have $\texttt{happly}(p, x) = \texttt{happly}(q, x)$. Now, using funext again, the dependent functions $(x \mapsto \texttt{happly}(p, x))$ and $(x \mapsto \texttt{happly}(q, x))$ are equal, and hence, applying $\texttt{ap}_\texttt{funext}$, so are $p$ and $q$.
          </p>
          <pre><code class="language-coq">Global Instance trunc_forall `{P : A -> Type} `{forall a, IsTrunc n (P a)}
  : IsTrunc n (forall a, P a) | 100.</code></pre>
          <p>
            Sets are just the first rung of the ladder of $n$-types, and may also be called the $0$-type; its defining property is that it has no non-trivial paths. Similarly, the $1$-type can be has no non-trivial paths between paths.
          </p>
          <pre><code class="language-coq">Notation Is1Type := IsTrunc 1.</code></pre>
          <p>
            A type $A$ is a $1$-type if for all $x, y : A$, and $p, q : x = y$, $r, s : p = q$, we have $r = s$. We can similarly define $2$-types, $3$-types, and so on.
          </p>
          <p class="exercise">
            If $A$ is a set, that is, $\texttt{isSet}(A)$ is inhabitated, then $A$ is a $1$-type.
          </p>
          <pre><code class="language-coq">(** Truncation levels are cumulative. *)
Global Instance trunc_succ `{IsTrunc n A}
  : IsTrunc n.+1 A | 1000.
Proof.
  generalize dependent A.
  simple_induction n n IH; simpl; intros A H x y.
  - apply contr_paths_contr.
  - apply IH, H.
Qed.</code></pre>
          <p>
            Another fact to keep in mind is that this stratification of types is not degenerate; in particular, not all types are sets. For instance, universe $\mathscr{U}$ is not a set.
          </p>
          <pre><code class="language-coq">Definition not_hset_Type : ~ (IsHSet Type).
Proof.
  intro HT.
  apply true_ne_false.
  pose (r := path_ishprop (path_universe equiv_negb) 1).
  refine (_ @ (ap (fun q => transport idmap q false) r)).
  symmetry; apply transport_path_universe.
Defined.</code></pre>
          <h2 id="propositions-as-types">
            Propositions as types?
          </h2>
          <p>
            Our previous straightforward interpretation of "propositions as types" do not work anymore. The statements of `double negation` and `law of excluded middle` do not function as they do in classical type theory; in particular, they are incompatible with the univalence axiom.
          </p>
          <p class="exercise">
            For $A : \mathscr{U}$, we do not have $\neg(\neg A) \rightarrow A$.
          </p>
          <p class="exercise">
            For $A : \mathscr{U}$, we do not have $A + \neg A$.
          </p>
          <h2 id="mere-propositions">
            Mere propositions
          </h2>
          <p>
            Propositions-as-types have good and bad properties. Both have a common cause: when types are viewed as propositions, they contain more information than mere truth or falsity, and all "logical" constructions on them must respect this additional information. This suggests that we could obtain a more conventional logic by restricting attention to types that do not contain any more information than the truth value, and only regarding these as logical propositions.
          </p>
          <p>
            Indeed, if $A$ will be "true" if it is inhabitated, and false if its inhabit yields a contradiction (i.e. $A \rightarrow \mathbb{0}$). Now, for example, if we're given an element of $\mathbb{2}$, it contains one bit of additional information: which element of $\mathbb{2}$ we are given. By contrast, when we're given an element of $\mathbb{1}$ (i.e. $\star$), we receive no more information than the mere fact that $\mathbb{1}$ contains an element, since any two elements of $\mathbb{1}$ are equal to each other. This suggests the following definition:
          </p>
          <p class="exercise">
            Type $P$ is a `mere proposition` if forall $x, y : P$, we have $x = y$.
          </p>
          <p>
            For $P : \mathscr{U}$,
          </p>
          <p class="mathjax">
            $$
            \texttt{isProp}(P) :\equiv \Pi_{x, y : P} x = y
            $$
          </p>
          <p>
            Thus, to assert that $P$ is a mere proposition means to exhibit an inhabitant of $\texttt{isProp}(P)$, which is a dependent function connecting any two elements of $P$ by a path. The continuity/naturality of this function impiles not only that any two elements of $P$ are equal, but also that $P$ contains no higher homotopies either.
          </p>
          <p class="exercise">
            If $P$ is a mere proposition, and $x_0 : P$, then $P \simeq \mathbb{1}$.
          </p>
          <pre><code class="language-coq">(** If an hprop is inhabited, then it is equivalent to [Unit]. *)
Lemma if_hprop_then_equiv_Unit (hprop : Type) `{IsHProp hprop} :  hprop -> hprop <~> Unit.
Proof.
  intro p.
  apply equiv_iff_hprop.
  - exact (fun _ => tt).
  - exact (fun _ => p).
Defined.</code></pre>
          <p class="exercise">
            If $P$ and $Q$ are mere propositions such that $P \rightarrow Q$ and $Q \rightarrow P$, then $P \simeq Q$.
          </p>
          <pre><code class="language-coq">(** Two propositions are equivalent as soon as there are maps in both directions. *)
Definition isequiv_iff_hprop `{IsHProp A} `{IsHProp B}
  (f : A -> B) (g : B -> A)
  : IsEquiv f.
Proof.
  apply (isequiv_adjointify f g);
    intros ?; apply path_ishprop.
Defined.</code></pre>
          <p>
            A space that is homotopy equivalent to $\mathbb{1}$ is said to be contractible. Thus, any mere proposition that is inhabitated is contractible. On the other hand, the uninhabited type $\mathbb{0}$ is also vacuously a mere proposition.
          </p>
          <p>
            Note that a type $A$ is a set if and only if, for $x, y : A$, the identity type $x =_A y$ is a mere proposition.
          </p>
          <p class="exercise">
            Every mere proposition is a set.
          </p>
          <p class="exercise">
            For any type $A$, types $\texttt{isProp}(A)$ and $\texttt{isSet}(A)$ are mere propositions.
          </p>
          <pre><code class="language-coq">(** Truncatedness is an hprop. *)
Global Instance ishprop_istrunc `{Funext} (n : trunc_index) (A : Type)
  : IsHProp (IsTrunc n A) | 0.</code></pre>
          <h2 id="classical-versus-intuitionistic-logic">
            Classical versus intuitionistic logic
          </h2>
          <p>
            With the notion of mere proposition, we can now give a proper formulation of LEM and double negation:
          </p>
          <p class="mathjax">
            $$
            \texttt{LEM} :\equiv \Pi_{A : \mathscr{U}} (\texttt{isProp}(A) \rightarrow (A + \neg A)) \\
              \Pi_{A : \mathscr{U}} (\texttt{isProp}(A) \rightarrow (\neg\neg A \rightarrow A))
            $$
          </p>
          <p>
            These are seen as being logically equivalent to each other. Renaming for clarity:
          </p>
          <p class="mathjax">
            $$
            \texttt{LEM}_\infty :\equiv \Pi_{A : \mathscr{U}} (A + \neg A)
            $$
          </p>
          <ol class="olitems" type="i" start="1">
            <li>
              A type $A$ is `decidable` if $A + \neg A$.
            </li>
            <li>
              A type family $B : A \rightarrow \mathscr{U}$ is decidable if $\Pi_{a : A}(B(a) + \neg B(a))$.
            </li>
            <li>
              $A$ has decidable equality if $\Pi_{a, b : A} ((a = b) + \neg(a = b))$.
            </li>
          </ol>
          <pre><code class="language-coq">Class Decidable (A : Type) :=
  dec : A + (~ A).</code></pre>
          <pre><code class="language-coq">Class DecidablePaths (A : Type) :=
  dec_paths : forall (x y : A), Decidable (x = y).</code></pre>
          <h2 id="subsets-and-propositional-resizing">
            Subsets and propositional resizing
          </h2>
          <p>
            Suppose $P : A \rightarrow \mathscr{U}$  is a type family with each type $P(x)$ regarded as a proposition. Then $P$ itself is a predicate on $A$, or a property of elements of $A$. What we regard as $\{x \in A \mid P(x)\}$ in set theory can be regarded as $\Sigma_{x : A} P(x)$ in type theory. For a general element $P$, $P(a)$ has more than one distinct proof; but if $P$ is a mere proposition, this cannot happen.
          </p>
          <p class="exercise">
            Suppose $P : A \rightarrow \mathscr{U}$ is a type famiy such that $P(x)$ is a mere proposition for all $x : A$. If $u, v : \Sigma_{x : A} P(x)$ are such that $\texttt{pr}_1(u) = \texttt{pr}_1(v)$, then $u = v$.
          </p>
          <pre><code class="language-coq">(** ** Subtypes (sigma types whose second components are hprops) *)

(** To prove equality in a subtype, we only need equality of the first component. *)
Definition path_sigma_hprop {A : Type} {P : A -> Type}
           `{forall x, IsHProp (P x)}
           (u v : sigT P)
: u.1 = v.1 -> u = v
  := path_sigma_uncurried P u v o pr1^-1.</code></pre>
          <p>
            For instance, recall that we defined
          </p>
          <p class="mathjax">
            $$
            A \simeq B :\equiv \Sigma_{f : A \rightarrow B} \texttt{isequiv}(f)
            $$
          </p>
          <p>
            where each type $\texttt{isequiv}(f)$ was supposed to be a mere proposition. It follows that if two equivalences have equal underlying functions, then they are equal as equivalences. In $\Sigma_{x : A} P(x)$, $P$ can be thought of as a `subtype` of $A$. We may write $a \in \{x : A \mid P(x)\}$ to refer to the mere proposition $P(a)$. If it holds, we say that $a$ is a `member` of $P$. Similarly, $P \subseteq Q$ can be written as $\Pi_{x : A} (P(x) \rightarrow Q(x))$.
          </p>
          <p>
            As further examples of subtypes, we may define the "subuniverses" of sets and propositions in $\mathscr{U}$:
          </p>
          <p class="mathjax">
            $$
            \texttt{Set}_\mathscr{U} :\equiv \{A : \mathscr{U} \mid \texttt{isSet}(A)\} \\
              \texttt{Prop}_\mathscr{U} :\equiv \{A : \mathscr{U} \mid \texttt{isProp}(A)\}
            $$
          </p>
          <p>
            Recall that for any two universes $\mathscr{U}_i$ and $\mathscr{U}_{i + 1}$, if $A : \mathscr{U}_i$, then $A : \mathscr{U}_{i + 1}$. For sets and mere propositions, we therefore have maps:
          </p>
          <p class="mathjax">
            $$
            \texttt{Set}_{\mathscr{U}_i} \rightarrow \texttt{Set}_{\mathscr{U}_{i + 1}} \\
              \texttt{Prop}_{\mathscr{U}_i} \rightarrow \texttt{Prop}_{\mathscr{U}_{i + 1}}
            $$
          </p>
          <p>
            However, the former cannot be an equivalence, as making it so would remind us of paradoxes in Cantorian set theory. However, the latter could be an equivalence, and we consier adding the `propositional resizing axiom`:
          </p>
          <p class="exercise">
            The map $\texttt{Prop}_{\mathscr{U}_i} \rightarrow \texttt{Prop}_{\mathscr{U}_{i + 1}}$ is an equivalence.
          </p>
          <p>
            It essentially says that any mere proposition in universe $\mathscr{U}_{i + 1}$ can be resized to an equivalent one in $\mathscr{U}_i$. It follows automatically if $\mathscr{U}_{i + 1}$ satisfies LEM. This is a form of `impredicativity` for mere propositions, and by avoiding its use, our type theory will remain predicative.
          </p>
          <p>
            In practice, however, what we want is a slightly different statement, that a universe $\mathscr{U}$ under consideration contains a type which "classifies all mere propositions". In other words, we want a type $\Omega : \mathscr{U}$ together with an $\Omega$-indexed family of mere propositions, which contains every mere proposition, upto equivalence. This follows from the propositional resizing axiom, if $\mathscr{U}$ is not the smallest univese $\mathscr{U}_0$, then we can define $\Omega :\equiv \texttt{Prop}_{\mathscr{U}_0}$.
          </p>
          <p>
            In the absence of propositional resizing, the definition of `power set` depends on the choice of $\mathscr{U}$. In its presence, however, one can define the power set to be:
          </p>
          <p class="mathjax">
            $$
            \mathscr{P}(A) :\equiv (A \rightarrow \Omega)_i
            $$
          </p>
          <p>
            which is then independent of $\mathscr{U}$.
          </p>
          <h2 id="the-logic-of-mere-propositions">
            The logic of mere propositions
          </h2>
        </article>
      </main>
      <nav>
        <ul>
          <li>
            <a href="/index">index</a>
          </li>
          <li>
            <a href="/ag">ag</a>
          </li>
          <li>
            <a href="/algebra">algebra</a>
          </li>
          <li>
            <a href="/attic">attic</a>
          </li>
          <li>
            <a href="/category">category</a>
          </li>
          <li>
            <a href="/notes">notes</a>
          </li>
          <li>
            <a href="/topoi">topoi</a>
          </li>
          <li>
            <a href="/topology">topology</a>
          </li>
        </ul>
      </nav>
    </div>
  </body>
</html>