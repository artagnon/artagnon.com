On Go

I would argue that C is probably the easiest language to understand,
if you know the basics of hardware. C is essentially portable
assembly. The C standard is tiny, and the behaviors are very clearly
defined. The challenge is not in understanding the language, but
rather in honing the engineering discipline required to use it to
write real-world programs.

It lacks a garbage collector because there was no concept of garbage
collector when the language was created. A C program does not provide
enough information for a good garbage collector: the best we can do is
a conservative garbage collector, Boehm. The garbage collector adds to
the running-cost to the program for the promise of automatic memory
management. While the GC might run concurrently, any sort of
relocation (for compacting) will require it to pause the entire
program: these GC pauses can be fatal if your program is the Linux
kernel or some high-frequency trading application. Even otherwise, it
is important to remember that every GC introduces trade-offs; the
"freedom" from manual memory management is only worth it if your GC is
good.

When I'm not writing C, I like writing Ruby. I like that it's a
beautiful evolving language packed with features. And for the little
applications I'm writing, I don't care even if it takes a second
longer. I like that I'm not being verbose about anything, and not
manually managing memory. Writing something like Jekyll in C would be
an absolute pain in the arse, and totally not worth it. Obviously, the
lesson is: use the right tool for the right job.

The pthreads API can certainly be very intimidating, and it requires a
lot of practice to master threading in C. I like that Go has taken the
concept of coroutines from Lisp (Scheme's call/cc) and turned it into
something called Gorountines in imperative land. Although it's nothing
novel, I won't deny that it's a nice abstraction to work with while
doing multi-threaded programming.

If we were to redo C from scratch today, I'd definitely bake in more
safety features. Probably design a close garbage collected
dialect. For better or worse, that's an entirely theoretical scenario:
we have Go today, but I'm not sure where exactly it fits in:

1. It obviously can't replace C in linux, git, zlib, ssh, openssl,
   libcurl, nginx, varnish, or anything as core.

2. Since it doesn't have generics or any higher OO features, it can't
   displace C++ in chrome or llvm.

3. When python, ruby, javascript are around, why will anyone want to
   use a strongly typed language for writing web applications? Okay,
   maybe some intensive web services like search.

Tools? The most popular Go repositories on GitHub are dotcloud/docker
(software deployment tool), burke/zeus (Rails preloader) and
ha/doozerd (a very specific kind of datastore).

Might be useful in Android development, but is everyone's stuck in a
Dalvik swamp there.
