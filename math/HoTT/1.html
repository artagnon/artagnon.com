<!DOCTYPE html>
<html lang="en">
  <head>
    <title>[HoTT/1] Type Theory | artagnon.com</title>
    <meta charset="utf-8" />
    <meta name="description" content="Ramkumar Ramachandra&#39;s personal website" />
    <meta name="HandheldFriendly" content="true" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index,follow" />
    <link rel="icon" href="/dist/favicon.ico" />
    <link rel="stylesheet" href="/dist/style.min.css" />
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/cash/6.0.1/cash.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.35/dayjs.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.35/plugin/relativeTime.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      extensions: ["tex2jax.js"], jax: ["input/TeX","output/HTML-CSS"],
      "HTML-CSS": { styles: {".MathJax_Preview": {visibility: "hidden"}} },
      tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]},
      TeX: {extensions: ["/dist/xypic.min.js","AMSmath.js","AMSsymbols.js"]} });
    </script>
    <link rel="preload" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/solarized-light.min.css" as="style" onload="this.onload=null;this.rel=&#39;stylesheet&#39;" />
    <noscript>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/solarized-light.min.css" />
    </noscript>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/coq.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/cpp.min.js"></script>
    <script defer="" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/haskell.min.js"></script>
    <script defer="" src="/dist/script.min.js"></script>
  </head>
  <body>
    <div id="wrapper">
      <nav>
        <div>
          <a href="/"><img src="/dist/artagnon.com.png" /></a>
        </div>
        <div id="topics">
          <ul>
            <li>
              <a href="/articles">articles</a>
            </li>
            <li>
              <a href="/computing">computing</a>
            </li>
            <li>
              <a href="/math">math</a>
            </li>
          </ul>
        </div>
      </nav>
      <main>
        <header>
          <h1>
            [HoTT/1] Type Theory
          </h1>
          <div id="metadata">
            <span id="timestamp"><time datetime="2020-05-27" class="begin">Wed, 27 May 2020 12:24:05 +0200</time><span class="to">↪</span><time datetime="2020-12-16" class="end">Wed, 16 Dec 2020 11:08:44 +0100</time></span><br /><span id="locations"><address>Paris</address></span>
          </div>
        </header>
        <article>
          <p class="blurb">
            This brief exposé lays the foundations for studying homotopy type theory; the concepts from here will re-appear in <a href="/HoTT/2">HoTT/2</a>, with fresh interpretations. It corresponds exactly to Ch.1 of the HoTT book.
          </p>
          <p>
            To specify a new type in HoTT, we need to specify four different rules: formation, introduction, elimintion, computation (FIEC).
          </p>
          <ol class="olitems" type="i" start="1">
            <li>
              How to form a new type of this kind. For example $\Pi_{(x : A)} B(x)$
            </li>
            <li>
              How to construct elements of this kind. For example, a function type has one constructor: $f(x) :\equiv 2x$.
            </li>
            <li>
              How to use elements of this type. These are called eliminators or <mark>elimination rules</mark>. For instance, a function type has one eliminator, namely function application.
            </li>
            <li>
              How the eliminator acts on the constructor. For example, $(\lambda x . \phi)(a)$ is judgementally equal to the expanded function $\lambda f . f(x)$.
            </li>
            <li>
              An optional uniqueness principle which expresses uniqueness into or out of the type. Every element of the type is uniquely determined by results of applying type eliminators to it. It is often a provable propositional equality: in this case, we call it <mark>propositional uniqueness principle</mark>.
            </li>
          </ol>
          <p>
            Broadly speaking, there are two kinds of types: $\Pi$ (which turns out to be a degenerate case of an inductive type, which we will see later) and $\Sigma$.
          </p>
          <h2 id="the-dependent-product-type-pi-type">
            The dependent product type ($\Pi$-type)
          </h2>
          <p>
            Instead of defining projections $pr1$ and $pr2$ for the two projections from the pair, we will define a "recursor" as follows:
          </p>
          <div class="mathjax">
            $$
            rec_{A \times B} : \Pi_{C : \mathscr{U}} (A \times B \times C) \rightarrow A \times B \rightarrow C \\
              rec_{A \times B}(C, g, (a, b)) :\equiv g(a)(b)
            $$
          </div>
          <p>
            So that:
          </p>
          <div class="mathjax">
            $$
            pr1 :\equiv rec_{A \times B}(A, \lambda a . \lambda b . a) \\
              pr2 :\equiv rec_{A \times B}(B, \lambda a . \lambda b . b)
            $$
          </div>
          <p>
            In order to be able to write dependent functions over the product type, we can define function $f : \Pi_{x : A \times B} C(x)$ by providing $g : \Pi_{x : A} \Pi_{x : B} C((x, y))$ with the defining equation $f((x, y)) = g(x)(y)$.
          </p>
          <p>
            To prove a property for all elements of a prduct, it is enough to prove it for its canonical elements (the ordered pairs). In the universal case, we call the resulting function induction for product types:
          </p>
          <div class="mathjax">
            $$
            ind_{A \times B} : \Pi_{C : A \times B \rightarrow U} (\Pi_{x : A}\Pi_{y : B} C((x, y))) \rightarrow \Pi_{x : A \rightarrow B} C(x)
            $$
          </div>
          <p>
            with the defining equation:
          </p>
          <div class="mathjax">
            $$
            ind_{A \times B}(C, g, (a, b)) :\equiv g(a)(b)
            $$
          </div>
          <p>
            Because induction describes how to use an element of the product type, induction is often called the <mark>dependent eliminator</mark>; recursion is called the <mark>non-dependent eliminator</mark>.
          </p>
          <p>
            Comment: the induction for the unit type turns out to be more useful than the recursor:
          </p>
          <div class="mathjax">
            $$
            uniq_1 : \Pi_{x : \mathbf{1}} x = \star \\
              uniq_1(x) :\equiv refl_\star
            $$
          </div>
          <h2 id="the-dependent-pair-type-sigma-type">
            The dependent pair type ($\Sigma$-type)
          </h2>
          <p>
            The dependent pair type is written $\Sigma_{x : A}, B(x)$. When the second component doesn't depend on the first, we get the cartesian product type $A \times B$. The first projection follows a straightforward extraction:
          </p>
          <div class="mathjax">
            $$
            pr1 : (\Sigma_{x : A} B(x)) \rightarrow A
            $$
          </div>
          <p>
            However, the second projection must be a dependent function, whose type involves the first projection function:
          </p>
          <div class="mathjax">
            $$
            pr2 : \Pi_{p: \Sigma_{x : A} B(x)} B(pr1(p))
            $$
          </div>
          <p>
            Thus, we need the induction principle for $\Sigma$-types (the <mark>dependent eliminator</mark>):
          </p>
          <div class="mathjax">
            $$
            g : \Pi_{a : A}\Pi_{b : B(a)} C((a, b))
            $$
          </div>
          <p>
            We can then derive a function:
          </p>
          <div class="mathjax">
            $$
            f : \Pi_{p:\Sigma_{x : A}, B(x)} C(p)
            $$
          </div>
          <p>
            In order to package up the recursion and induction principles into a recursor for $\Sigma$, which we will not bother elaborating here. As usual, the recursor is the special case of induction when the family $C$ is fixed.
          </p>
          <p>
            Now, we present the <mark>type-theoretic axiom of choice</mark> where $R : A \rightarrow B \rightarrow U$:
          </p>
          <div class="mathjax">
            $$
            ac : (\Pi_{a : A} \Sigma_{y : B} R(x, y)) \rightarrow (\Sigma_{f : A \rightarrow B} \Pi_{x : A} R(x, f(x))) \\
              ac(g) :\equiv (\lambda x . pr_1(g(x)), \lambda x . pr2(g(x)) \\
              \lambda x . pr_1(g(x)) : A \rightarrow B \\
              \lambda x . pr_2(g(x)) : \Pi_{x : A} R(x, pr_1(g(x)))
            $$
          </div>
          <p>
            In English, this reads: if $\forall x : A$, there is a $y : B$ such that $R(x, y)$, then $\exists f : A \rightarrow B$ such that $\forall x : A$, we have $R(x, f(x))$. We will provide a more familar axiom of choice later.
          </p>
          <p>
            Let's also provide an example of the magma type, in which the second component depends on the first component:
          </p>
          <div class="mathjax">
            $$
            Magma :\equiv \Sigma_{A : \mathscr{U}} A \rightarrow A \rightarrow A
            $$
          </div>
          <h2 id="interlude-coproduct-types-and-booleans">
            Interlude: Coproduct types and booleans
          </h2>
          <p>
            The recursor for coproduct types can be written as:
          </p>
          <div class="mathjax">
            $$
            rec_{A + B} : \Pi_{C : \mathscr{U}} (A \rightarrow C) \rightarrow (B \rightarrow C) \rightarrow A + B \rightarrow C \\
              rec_{A + B}(C, g_0, g_1, inl(a)) :\equiv g_0(a) \\
              rec_{A + B}(\Pi_{C : \mathscr{U}} (C, g_0, g_1, inr(a)) :\equiv g_1(a)
            $$
          </div>
          <p>
            The if-then-else pattern in general programming practice utilizes booleans as follows:
          </p>
          <div class="mathjax">
            $$
            rec_2 : \Pi_{C : \mathscr{U}} C \rightarrow C \rightarrow \mathbf{2} \rightarrow C \\
              rec_2(C, c_0, c_1, 0_\mathbb{2}) :\equiv c_0 \\
              rec_2(C, c_0, c_1, 1_\mathbb{2}) :\equiv c_1
            $$
          </div>
          <h2 id="mathbb-n-and-primitive-recursion">
            $\mathbb{N}$ and primitive recursion
          </h2>
          <p>
            To define infinite types like $\mathbb{N}$, we need the additional concept of well-founded recursion. We can package the recursor into a single function, as previously:
          </p>
          <div class="mathjax">
            $$
            rec_\mathbb{N} : \Pi_{C : \mathscr{U}} C \rightarrow (\mathbb{N} \rightarrow C \rightarrow C) \rightarrow \mathbb{N} \rightarrow C
            $$
          </div>
          <p>
            Given step 0, and a next-step function, we can define:
          </p>
          <div class="mathjax">
            $$
            rec_{\mathbb{N}}(C, c_0, c_s, 0) = c_0 \\
              rec_{\mathbb{N}}(C, c_0, c_s, succ(n)) = c_s(n, rec_\mathbb{N}(C, c_0, c_s, n))
            $$
          </div>
          <p>
            We can generalize general recursion to dependent functions as follows:
          </p>
          <div class="mathjax">
            $$
            ind_{\mathbb{N}} : \Pi_{C : \mathbb{N} \rightarrow U} C(0) \rightarrow (\Pi_{n : \mathbb{N}} C(n) \rightarrow C(succ(n))) \rightarrow \Pi_{n \in \mathbb{N}} C(n)
            $$
          </div>
          <p>
            with these defining equations:
          </p>
          <div class="mathjax">
            $$
            f(0) :\equiv c_0 \\
              f(succ(n)) :\equiv c_s(n, f(n))
            $$
          </div>
          <h2 id="identity-types">
            Identity types
          </h2>
          <p>
            The cornerstone of homotopy type theory is that there can be more than one witness that two objects are equal. These correspond to paths or equivalences in the given space.
          </p>
          <p>
            The identity family takes two copies of $A$, and illustrates an equality between them: $id_A : A \rightarrow A \rightarrow \mathscr{U}$. The formation rule says that given a type $A : \mathscr{U}$ and two elements $a, b : A$, we can form the type $(a =_A b) : \mathscr{U}$ in the same universe. The introduction rule is a dependent function called reflexivity:
          </p>
          <div class="mathjax">
            $$
            \texttt{refl} : \Pi_{a : A} a = a
            $$
          </div>
          <p>
            The elimination rule for identity types is subtle. We begin by considering the consequence that equals may be substituted for equals, called <mark>indiscrenability of identicals</mark>. For every family $C : A \rightarrow \mathscr{U}$, there is a function
          </p>
          <div class="mathjax">
            $$
            f : \Pi_{x, y : A} \Pi_{x =_A y} C(x) \rightarrow C(y)
            $$
          </div>
          <p>
            such that:
          </p>
          <div class="mathjax">
            $$
            f(x, x, \texttt{refl}_x) :\equiv id_{C(x)}
            $$
          </div>
          <h2 id="path-induction">
            Path induction
          </h2>
          <p>
            The induction principle for the identity type is called <mark>path induction</mark>. It can be seen as stating that the family of identity types is freely generated by elements of the form $\texttt{refl}_x : x = x$.
          </p>
          <p>
            Given functions:
          </p>
          <div class="mathjax">
            $$
            C : \Pi_{x, y : A} (x =_A y) \rightarrow \mathscr{U} \\
              c : \Pi_{x : A} C(x, x, \texttt{refl}_x)
            $$
          </div>
          <p>
            There is a function:
          </p>
          <div class="mathjax">
            $$
            f : \Pi_{x, y : A} \Pi_{p : x =_A y} C(x, y, p)
            $$
          </div>
          <p>
            such that
          </p>
          <div class="mathjax">
            $$
            f(x, x, \texttt{refl}_x) :\equiv c(x)
            $$
          </div>
          <p>
            We can conclude that $C(x, y)$ is a reflexive relation that holds whenever $x = y$.
          </p>
          <p>
            If we package up path induction into a single function, it takes the form:
          </p>
          <div class="mathjax">
            $$
            ind_{=A} : \Pi_{C : \Pi_{x, y : A} (x =_A y) \rightarrow \mathscr{U}} (\Pi_{x : A} C(x, x, \texttt{refl}_x)) \rightarrow \Pi_{x, y : A} \Pi_{p : x =_A y} C(x, y, p)
            $$
          </div>
          <p>
            with the equality, traditionally called $J$:
          </p>
          <div class="mathjax">
            $$
            ind_{=A}(C, c, x, x, \texttt{refl}_x) :\equiv c(x)
            $$
          </div>
          <p>
            Indiscrenability of identicals is an instance of path induction, as we will show later.
          </p>
          <p>
            By fixing a certain $a : A$, we can show <mark>based path induction</mark>, a simpler version:
          </p>
          <div class="mathjax">
            $$
            ind'_{=A} : \Pi_{a : A}\Pi_{C : \Pi_{a : A} (a =_A x) \rightarrow \mathscr{U}} C(a, \texttt{refl}_a) \rightarrow \Pi_{x : A} \Pi_{p : a =_A x} C(x, p)
            $$
          </div>
          <p>
            Since every path is of the form $\texttt{refl}_a$, if we prove a property for reflexivity paths, then we have provided it for all paths.
          </p>
          <p>
            Now, we must resolve a question: how can there be many different elements of the identity type (different paths), but also have an induction principle asserting that the only path is reflexivity? It is not that the identity type that is inductively defined; rather, it is the inductive family. In particular, path induction says that the family of types $x =_A y$, as $x$ and $y$ vary over all elements of $A$, inductively defined by the elements of the form $\texttt{refl}_x$. This means that to give an element of any other family, it suffices to consider the cases of the form $(x, y, p)$ dependent on a generic element $(x, y, p)$ of the identity family, it suffices to consider the cases of the form $(x, x, \texttt{refl}_x)$.
          </p>
          <p>
            In the homotopy interpretation, type of triples $(x, y, p)$, where $x, y$ are endpoints of the path $p$ (in other words, $\Sigma_{x, y : A} (x = y)$), is inductively generated by the constant loops at each point $x$. We will consequently see that that the space corresponding to $\Sigma_{x, y : A} (x = y)$ is a <mark>free path space</mark>. To conclude, $\Sigma_{y : A} (a = y)$ can be regarded as the type of all elements of $A$ which are equal to $a$.
          </p>
        </article>
      </main>
    </div>
  </body>
</html>